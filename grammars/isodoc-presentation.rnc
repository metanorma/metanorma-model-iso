# In the following, unaltered fields are uncommented. Changes in cardinality are still commented.
# When a semantic element wrapper are removed, as in <concept id=...>{content}</concept> => <concept>,
# that is indicated as "(UNWRAPPED)": in such cases, any anchor of the wrapper is lost, and
# alignment between Semantic and Presentation XML cannot be recovered through matching anchors
include "isodoc.rnc" {

## In addition to the new elements added to metanorma-extension:
## * Add <presentation-metadata><name>fonts</name><value>{..}</value></presentation-metadata> for every font required for Fontist.
## * Add <presentation-metadata><name>font-license-agreement</name><value>{..}</value></presentation-metadata> for 
##   any needed license agreement language.
## * Extract any attachments into an _{output filename}_attachments folder, to be linked to in HTML.
misccontainer = element metanorma-extension { 
  AnyElement+, 
  toc+, 
  preprocess-xslt*, 
  localized-strings, 
  metanorma-source-container
}

## Indicate that a table of contents for specific assets is required
toc = element toc {
  ## The type of asset to generate a separate table of contents for
  attribute type ( "figure" | "table" | "recommendation" ),
  ## The i18n'd title for the particular table of contents
  element title { PureTextElement+ }
}

## Preprocessing XSLT to apply for a specific output format
preprocess-xslt = element preprocess-xslt {
  ## The format on which to run this Preprocessing XSLT
  attribute format { "html" | "pdf" | "doc" },
  ## The XSLT to run on the Presentation XML, before passing it for processing on to the target format
  AnyElement+
}

## i18n equivalents, to be applied in PDF when needing to generate i18n output on the fly
localized-strings = element localized-strings {
  localized-string+
}

## i18n equivalence
localized-string = element localized-string {
  ## The name of the i18n string
  attribute key { text },
  attribute language { LanguageType },
  ## The i18n'd rendering of @key; e.g.
  ##   <localized-string key="table" language="fr">tableau</localized-string>
  text
}

## ONLY in the context of //bibdata/language
language = element language {
  ## of the languages present in document metadata, this language value corresponds to the document default
  attribute current { xsd:boolean }?,
  LanguageType
}

## ONLY in the context of //bibdata/locale
locale = element locale {
  ## of the locales present in document metadata, this locale value corresponds to the document default
  attribute current { xsd:boolean }?,
  LocaleType
}

## ONLY in the context of //bibdata/script
script = element script {
  ## of the scripts present in document metadata, this script value corresponds to the document default
  attribute current { xsd:boolean }?,
  ScriptType
}

address =
  element address {
    ## Address decomposed into its component parts
    AddressComponents?,
    ## If not already present, generate a preformatted version of the address, concatenating its component parts,
    ## delimited by linebreak
    formattedAddress
}

BibDataExtensionType =
  attribute schema-version { text }?,
  ## Duplicate doctype, giving a translation of the doctype into the current i18n language
  doctype+,
  docsubtype?,
  editorialgroup?,
  ics*,
  structuredidentifier*

status =
  element status {
     ## Duplicate stage, giving a translation of the stage into the current i18n language
     stage+,
     ## Duplicate substage, giving a translation of the substage into the current i18n language
     substage*,
     iteration?
}

BibliographicItem =
    attribute type { BibItemType }?,
    attribute schema-version { text }?,
    fetched?,
    formattedref?,
    btitle+,
    bsource*,
    docidentifier+,
    docnumber?,
    bdate*,
    contributor*,
    ## Duplicate edition, giving a translation of the substage into the current i18n language
    edition*,
    version*,
    biblionote*,
    language*,
    locale*,
    script*,
    bibabstract*,
    status?,
    copyright*,
    docrelation*,
    series*,
    medium?,
    bplace*,
    bprice*,
    extent*,
    bibliographic_size?,
    accesslocation*,
    license*,
    bclassification*,
    bkeyword*,
    validity?,
    depiction?

doctype = element doctype {
  ## Through i18n, generate a translation of the Semantic doctype value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?,
  attribute abbreviation { text }?,
  DocumentType
}

stage = element stage {
  ## Through i18n, generate a translation of the Semantic stage value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?,
  attribute abbreviation { text }?,
  text
}

substage = element substage {
  ## Through i18n, generate a translation of the Semantic substage value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?,
  attribute abbreviation { text }?,
  text
}

edition = element edition {
  ## Through i18n, generate a translation of the Semantic human-readable edition value, with language set to the current language.
  ## The original value is indicated with language="". The i18n may involve ordinals
  attribute language { LanguageType }?,
  attribute number { text }?,
  text
}

## All captions of blocks are prefixed by the i18n'd numbered label of the block, where applicable,
## followed by a delimiter (as dictated by the house style):
## e.g. the first table in a French document, with the label "Tabular data",
## becomes "Tableau 1 – Tabular data". If no caption is present, one is generated, without the delimiter;
## e.g. "Tableau 1". No prefix is added for blocks with @unnumbered = true, or notag = true.
tname = element name { NestedTextElement+ }

FormulaBody =
  stem,
  ## Any key in a formula is preceded with a paragraph with the i18n'd word "where" or "where_one" (for singular value).
  ## The key itself is given @class = formula_dl
  (p, dl)?,
  note

## All strings in table cells are broken up if they exceed a threshold of length
## (20 chars), in order to allow table cells not to be artificially widened
TdBody &= empty

## (UNWRAPPED): Strip autonumber element, strip `amend` wrapper
amend = 
  AmendType

AmendType =
    ## Remove locality, localityStack, classification, contributor.
    ## Replace the `description`  element with its children
    BasicBlock*,
    ## replace `newcontent` element with `quote`
    quote?

OlAttributes =
    BlockAttributes,
    ## The type of numbering to be applied to the list items is forced
    ## according to a fixed nesting hierarchy set for a flavour
    attribute type { ( "roman" | "alphabet" | "arabic" |
                       "roman_upper" | "alphabet_upper" ) }?

li =
  element li {
    ## an anchor is set for all //ol//li, because ordered list items can be cross-referenced
    RequiredId,
    LiAttributes,
    ## Each //ol//li has a label, set by //ol[@type] (e.g. "a", "ii", "C", "3"):
    ## this is made explicit for Presentation XML, so that it can render them if automatic list labelling doesn't work
    attribute label { string },
    LiBody
} 

TermSource =
    ## Concatenate all consecutive term sources and block sources into a single semicolon delimited expression
    termsource?

termsource = element termsource {
    attribute status { SourceStatusType },
    attribute type { SourceTypeType },
    origin,
    ## UNWRAP: Replace modification with a commma, then text representing the status, then a dash, then text representing the modification
    ## e.g.
    ##    <termsource status="adapted"><origin>...</origin><modification>enhanced</modification></termsource>
    ## becomes:
    ##    <termsource status="adapted"><origin>...</origin>, adapted – enhanced</termsource>
    TextElement*
}

## UNWRAP: replace <concept> with the rendered form of the crossreference
concept = element concept {
  ## refterm and renderterm are removed. The crossrefence, eref, erefstack, xref, termref, is replaced with
  ## the content of renderterm if present and requested (@ref),
  ## with the attributes of Semantic XML concept used to determine its rendering: 
  ## ital: italicise the crossreference text
  ## bold: boldface the crossreference text
  ## ref: append the citation of the concept definition (clause number, for local definitions)
  ## linkmention: use renderterm as the cross-reference text; if false, leave the cross-reference as is, to be resolved
  ## as is normal for Presentation XML
  ## linkref: cross-reference the citation of the concept definition to the source of that definition
  ## (same destination as linkmention). If false, unwrap the cross-references, and use only their text, with no cross-referencing
  ## e.g. 
  ##    <concept><refterm>term123</refterm> <renderterm>Term</renderterm> 
  ##       <eref bibitemid="ISO712" type="inline" citeas="ISO 712"/></concept>
  ## becomes
  ##    <em>Term</em> (<xref type="inline" target="ISO712">ISO 712</xref>)
  ( 
     ## Link to a definition of the term in a bibliographic entry
     eref |
     ## Stack of links to a definition of the term in a bibliographic entry
     erefstack |
     ## Link to a definition of the term in an element of the current document
     xref |
     ## Link to a definition of the term in a termbase
     termref
  )
}

## UNWRAP: replace <related> with the crossreference to the term being related to
related =
  ## paragraph is: 
  ##    <p><strong>{related/@type}:</strong> <em>{related/preferred}</em> 
  ##       ({related/xref | related/eref | related/termref})</p>
  ## e.g.
  ##    <related type='contrast'><preferred><expression><name>Fifth Designation</name></expression></preferred>
  ##       <xref target='second'/></related>
  ## becomes: 
  ##    <p><strong>CONTRAST:</strong> <em><preferred><strong>Fifth Designation</strong></preferred></em> 
  ##       (<xref target='second'>Clause 1.1</xref>)</p>
  paragraph

erefAttributes =
    attribute normative { xsd:boolean }?,
    ## Regenerated, based on any potential flavour-specific rendering of the bibliographic citation
    attribute citeas { text },
    attribute type { ReferenceFormat }?,
    attribute alt { text }?

## UNWRAP: lists of erefs with @connective attributes are resolved to a single human-readable string of
## eref, with connectives linking them; e.g. 
##    <erefstack><eref connective="from" target="A"/><eref connective="to" target="A"/></erefstack>
## becomes
##    from <eref connective="from" target="A"/> to <eref connective="to" target="A"/>
erefstack = (
  element eref { erefTypeWithConnective } |
  text
)+

## UNWRAP: lists of locality with @connective attributes are resolved to a single human-readable string of
## locality, with connectives linking them; e.g. 
##    <eref bibitemid="ISO712" type="inline" citeas="ISO 712">
##      <localityStack connective="and">
##        <locality type='clause'><referenceFrom>3.1</referenceFrom></locality>
##      </localityStack>
##      <localityStack connective="and">
##        <locality type='figure'><referenceFrom>b</referenceFrom></locality>
##      </localityStack>
##    </eref>
## becomes
##    <locality type='clause'><referenceFrom>3.1</referenceFrom></locality> and <locality type='figure'><referenceFrom>b</referenceFrom></locality>
localityStack =
   element localityStack {
     ( locality | text )*
 }

## UNWRAP: as with localityStack
sourcelocalityStack =
   element sourcelocalityStack {
     ( sourcelocality | text )*
 }

## UNWRAP: locality becomes text; e.g.
##     <locality type='clause'><referenceFrom>3.1</referenceFrom></locality>
## becomes
##     Clause 3.1
## If eref/@droploc = true, do not insert the locality name. If eref/@case = capital, titlecase it. 
## If  eref/@case = lowercase, lowercase it
locality = text

## UNWRAP: as with locality
sourcelocality = text

## UNWRAP: convert eref to xref (pointing to bibliography anchor, xref/@target = eref/@bibitemid),
## or link (if a URI for the reference is supplied in the bibitem being referenced).
## The locality text (locality, sourcelocality), if present, is inserted as part of the cross-referenced text.
## If the locality is an anchor, and the eref is converted to link, append the anchor to the URI.
## If there is no text in the Semantic XML eref, it is populated with eref/@citeas
eref =
  xref | hyperlink

## UNWRAP: as for eref
origin =
  xref | hyperlink

## UNWRAP: as for eref
quote-source =
  xref | hyperlink

## Move svg to image/svg, for consistency.
## If image contains Data URI-encoded SVG, make it image/svg with explicit SVG markup.
## If the image is EPS, convert it to SVG.
## If the image is SVG, convert it to EMF, and add that as a separate child along SVG (for use by Word).
## If the image is EMF, convert it to SVG, and add that along the img/src EMG (for use outside of Word)
image = element image { 
    RequiredId,
    ImageAttributes,
     element svg {
       ( text | AnyElement )+
     }?,
     element emf { AnyElement }?
}

## Any instances of pseudocode figures are processed as sourcecode is.
## If figure is labelled with figure/@class (e.g. "diagram"), use the i18n of figure/@class, rather than "Figure",
## to label the figure
figure &= empty

## UNWRAP: the links in svgmap are already resolved in standoc postprocessing, so they need not be retained
svgmap = figure

## If the xref is empty, it is resolved to the computed cross-reference label for the element being pointed to.
## <location>, the locations within the reference being specified, are resolved into text appended to the body, and removed as an element
XrefBody = PureTextElement+

## If the eref is empty, it is resolved to the citation of the bibliographic element being pointed to.
## <location>, the locations within the reference being specified, are resolved into text appended to the body, and removed as an element
ErefBody = PureTextElement+

## change identifier of requirement to just monospace
reqtlabel = tt

## UNWRAP: Dates marked up with value and format are converted into an i18n'd rendering of the date
date_inline |= text

## <span> with @style=text-transform... is converted into case transformed text (rather than leaving that to CSS).
## <span> with @custom-charset= is converted to include font markup in @style appropriate to that charset
span &= empty

passthrough_inline = element passthrough { 
  ## @formats is made mandatory, populated with "all" if missing, and brought in line with the permitted output formats
  ## for the current flavour
  attribute formats { text },
  (text | AnyElement)+
}

passthrough = element passthrough {
  ## Format of markup to be transferred, comma-delimited
  ## @formats is made mandatory, populated with "all" if missing, and brought in line with the permitted output formats
  ## for the current flavour
  attribute formats { text }?,
  (text | AnyElement)+
} 

ruby = element ruby { 
  ## text content of ruby, or recursing of ruby
  element rb { text | ruby },
  ## content of Semantic XML ruby/pronunciation or ruby/annotation
  element rt { text }
}   

## UNWRAP: Number formatting is applied to stem/mathml expressions: inline stem, and if number formatting is specified 
## (@data-metanorma-numberformat), ## formula/stem/mathml as well. 
## If the stem expression is MathML consisting only of mn, it is replaced with the text content of mn,
## to reduce processing load. If the stem expression does not already contain <asciimath>,
## an Asciimath version of the MathML is added, for human readability and potential round-tripping.
## If the attribute @linebreak is present in the MatML, two different MathML expressions are generated:
## math-no-linebreak, containing the original MathML, and math-with-linebreak, which breaks the source MathML
## expression up into separate MathML expressions, joined by <br/>: this is to enable correct rendering in Word.
## If the MathML has <strong> as an ancestor, <mstyle mathvariant="bold"> is wrapped around the MathML contents:
## this is because the PDF rendering is not dealing with boldfacing MathML when its container is boldface.
stem |= text


}

# end overrides

metanorma-source-container = element metanorma { metanorma-source }

## The metanorma-source element contains a copy of the Semantic XML, so that downstream
## consumers can process Semantic XML and Presentation XML in tandem. The Semantic and
## Presentation XML are aligned as follows, in order to avoid duplicate references and
## to segregate the embedded XML from processing:
##
## * Each element in metanorma-source is prefixed with semantic__ : <semantic__p>
## * Any namespaced element has semantic_ prefixed to its name : <mathml:semantic__math>
## * The root namespace of the embedded Semantic XML is stripped : <semantic__iso-document> (no ns)
## * Every attribute of the Semantic XML that is an identifier (id, name) is prefixed with semantic__ :
##   <semantic__p id="semantic__A123">
## * Every attribute of the Semantic XML that references an element identifier is prefixed with semantic__ :
##   <semantic_xref target="semantic__A123">
metanorma-source = element metanorma { AnyElement+ }
