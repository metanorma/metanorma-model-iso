# In the following, unaltered fields are uncommented. Changes in cardinality are still commented.
# When a semantic element wrapper are removed, as in <concept id=...>{content}</concept> => <concept>,
# that is indicated as "(UNWRAPPED)": in such cases, any anchor of the wrapper is lost, and
# alignment between Semantic and Presentation XML cannot be recovered through matching anchors
include "isodoc.rnc" {

## A tab or similar spacing; used to delimit clause numbers from clause titles
tab = element tab { empty }

## In addition to the new elements added to metanorma-extension:
## * Add <presentation-metadata><name>fonts</name><value>{..}</value></presentation-metadata> for every font required for Fontist.
## * Add <presentation-metadata><name>font-license-agreement</name><value>{..}</value></presentation-metadata> for 
##   any needed license agreement language.
## * Extract any attachments into an _{output filename}_attachments folder, to be linked to in HTML.
misccontainer = element metanorma-extension { 
  AnyElement+, 
  (ext_toc+ & localized-strings & metanorma-source-container & source-highlighter-css)
}

## CSS of the Rouge code highlighter for the document: consists of flavour default,
## plus any document-specific //metanorma-extension/clause[title = 'user-css']/sourcecode/* 
source-highlighter-css = element source-highlighter-css { text }

## Indicate that a table of contents for specific assets is required
ext_toc = element toc {
  ## The type of asset to generate a separate table of contents for
  attribute type { "figure" | "table" | "recommendation" },
  ## The i18n'd title for the particular table of contents
  element title { PureTextElement+ }
}

## i18n equivalents, to be applied in PDF when needing to generate i18n output on the fly
localized-strings = element localized-strings {
  localized-string+
}

## i18n equivalence
localized-string = element localized-string {
  ## The name of the i18n string
  attribute key { text },
  attribute language { LanguageType },
  ## The i18n'd rendering of @key; e.g.
  ##   <localized-string key="table" language="fr">tableau</localized-string>
  text
}

## ONLY in the context of //bibdata/language
language = element language {
  ## of the languages present in document metadata, this language value corresponds to the document default
  attribute current { xsd:boolean }?,
  LanguageType
}

## ONLY in the context of //bibdata/locale
locale = element locale {
  ## of the locales present in document metadata, this locale value corresponds to the document default
  attribute current { xsd:boolean }?,
  LocaleType
}

## ONLY in the context of //bibdata/script
script = element script {
  ## of the scripts present in document metadata, this script value corresponds to the document default
  attribute current { xsd:boolean }?,
  ScriptType
}

## If Semantic XML content is replicated in a Presentation XML element, any @id attributes need to be restricted
## to the Presentation XML element, because that is what anchors in rendered documents will point to.
## Any @id attributes in the source Semantic XML element need to be moved to @original-id, to avoid there
## being two elements in the Presentation XML with the same @id
RequiredId &=
    attribute original-id { xsd:ID }?

## As for RequiredId
OptionalId &=
    attribute original-id { xsd:ID }?

address =
  element address {
    ## Address decomposed into its component parts
    AddressComponents?,
    ## If not already present, generate a preformatted version of the address, concatenating its component parts,
    ## delimited by linebreak
    formattedAddress
}

BibDataExtensionType =
  attribute schema-version { text }?,
  ## Duplicate doctype, giving a translation of the doctype into the current i18n language
  doctype+,
  docsubtype?,
  flavor,
  editorialgroup?,
  ics*,
  structuredidentifier*

status =
  element status {
     ## Duplicate stage, giving a translation of the stage into the current i18n language
     stage+,
     ## Duplicate substage, giving a translation of the substage into the current i18n language
     substage*,
     iteration?
}

BibliographicItem =
    attribute type { BibItemType }?,
    attribute schema-version { text }?,
    fetched?,
    formattedref?,
    btitle+,
    bsource*,
    docidentifier+,
    docnumber?,
    bdate*,
    contributor*,
    ## Duplicate edition, giving a translation of the substage into the current i18n language
    edition*,
    version*,
    biblionote*,
    language*,
    locale*,
    script*,
    bibabstract*,
    status?,
    copyright*,
    docrelation*,
    series*,
    medium?,
    bplace*,
    bprice*,
    extent*,
    bibliographic_size?,
    accesslocation*,
    license*,
    bclassification*,
    bkeyword*,
    validity?,
    depiction?

bDateAttributes |=
  ## Through i18n, generate a translation of the Semantic date value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?

doctype = element doctype {
  ## Through i18n, generate a translation of the Semantic doctype value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?,
  attribute abbreviation { text }?,
  DocumentType
}

stage = element stage {
  ## Through i18n, generate a translation of the Semantic stage value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?,
  attribute abbreviation { text }?,
  text
}

substage = element substage {
  ## Through i18n, generate a translation of the Semantic substage value, with language set to the current language.
  ## The original value is indicated with language=""
  attribute language { LanguageType }?,
  attribute abbreviation { text }?,
  text
}

edition = element edition {
  ## Through i18n, generate a translation of the Semantic human-readable edition value, with language set to the current language.
  ## The original value is indicated with language="". The i18n may involve ordinals
  attribute language { LanguageType }?,
  attribute number { text }?,
  text
}

NestedTextElement |= semx

## Autonumbers and other content duplicated from Semantic XML into new Presentation XML content is annotated by the <semx> element,
## which connects the inserted content back to its Semantic XML source. So in the generated crossreference "Clause *2*, Note 1",
## the "1" is marked up as <semx element='autonum' source='A'>2</semx>, indicating that the "2" is an auto-number
## associated with the element with id A (the Clause tag). In a caption like "Clause 2: *Discussion*", the "Discussion"
## is marked up as <semx element='title' source='B'>, indicating that the user-supplied title content is taken from the
## Semantic XML <title> element with id B.
semx = element semx {
  ## Name of source element that the Semantic XML content is derived from. "autonum" indicates that the content is an autonumber.
  attribute element { text },
  ## id of the source element that the Semantic XML content is derived from.
  attribute source { xsd:IDREF },
  ## Duplicated Semantic XML content, or content derived from it (such as an autonumber).
  PureTextElement*
}

## Captions always have inserted into them the delimiter text that separates them from the block content
## they apply to, rather than leaving that to the renderer. So formula/name is transformed from "1" to "(1)";
## note/name is populated as "Note 1:" or "NOTE â€”"  and not just "Note". In future versions, the autonumber and delimiter
## content will be tagged separately.
tname = element name { NestedTextElement+ }

## Asset captions are transformed analogously to section-title; see documentation there
## (with fmt-name replacing fmt-title as the Presentation XML-specific caption of a block).
## The following additional provisos apply:
## * fmt-caption-label is not added to fmt-name
tname =
  element name {
    attribute id { xsd:ID },
    NestedTextElement+
  }?,
  fmt-name,
  fmt-xref-label*

## See fmt-title for rationale for the Presentation XML counterpart to name and title, and how it is structured.
## The following additional provisos apply to fmt-name:
##
## * fmt-caption-label is not added to fmt-name, not only if @unnumbered = true, but also if @notag = true
## * Autonumber delimiters are added to the caption, using span[@class = 'fmt-autonum-delim']; so formula
## will have <name>1</name>, but
##   <fmt-name>
##     <span class="fmt-caption-delim">
##       <span class="fmt-autonum-delim">(</span>
##       <semx element="autonum" source="A">1</semx>
##       <span class="fmt-autonum-delim">)</span>
##     </span>
##   </fmt-name>
## * As with inline section titles, the fmt-name content may be followed immediately by block content; in that
## case, span[@class = 'fmt-label-delim'] separates the name from the content; e.g. 
##   <note>
##     <fmt-name>
##       <span class="fmt-caption-delim">
##         <span class="fmt-element-name">NOTE</span>
##         <semx element="autonum" source="A">1</semx>
##       </span>
##       <span class="fmt-label-delim">:<tab/></span>
##     </fmt-name>
##     <p>This is a note...</p>
##  To be rendered as:
##    <p>NOTE 1:<tab/>This is a note...</p>
fmt-title = element fmt-title {
    ## A hierarchical section title is given an explicit count of its nesting depth, as a hint for rendering
    attribute depth { xsd:integer }?,
    ## The ID of the title that the fmt-title is derived from
    attribute source { xsd:IDREF }?,
    TextElement*
  } 

FormulaBody =
  stem,
  ## Any key in a formula is preceded with a paragraph with the i18n'd word "where" or "where_one" (for singular value).
  ## The key itself is given @class = formula_dl
  (p, dl)?,
  note

## (UNWRAPPED): Strip autonumber element, strip `amend` wrapper
amend = 
  AmendType

AmendType =
    ## Remove locality, localityStack, classification, contributor.
    ## Replace the `description`  element with its children
    BasicBlock*,
    ## replace `newcontent` element with `quote`
    quote?

OlAttributes =
    BlockAttributes,
    ## The type of numbering to be applied to the list items is forced
    ## according to a fixed nesting hierarchy set for a flavour
    attribute type { ( "roman" | "alphabet" | "arabic" |
                       "roman_upper" | "alphabet_upper" ) }?

li =
  element li {
    ## an anchor is set for all //ol//li, because ordered list items can be cross-referenced
    RequiredId,
    LiAttributes,
    ## Each //ol//li has a label, set by //ol[@type] (e.g. "a", "ii", "C", "3"):
    ## this is made explicit for Presentation XML, so that it can render them if automatic list labelling doesn't work
    attribute label { string },
    LiBody
} 

TermSource =
    ## Concatenate all consecutive term sources and block sources into a single semicolon delimited expression
    termsource?

termsource = element termsource {
    attribute status { SourceStatusType },
    attribute type { SourceTypeType },
    origin,
    ## UNWRAP: Replace modification with a commma, then text representing the status, then a dash, then text representing the modification
    ## e.g.
    ##    <termsource status="adapted"><origin>...</origin><modification>enhanced</modification></termsource>
    ## becomes:
    ##    <termsource status="adapted"><origin>...</origin>, adapted â€“ enhanced</termsource>
    TextElement*
}

## UNWRAP: replace <concept> with the rendered form of the crossreference
concept = element concept {
  ## refterm and renderterm are removed. The crossrefence, eref, erefstack, xref, termref, is replaced with
  ## the content of renderterm if present and requested (@ref),
  ## with the attributes of Semantic XML concept used to determine its rendering: 
  ## ital: italicise the crossreference text
  ## bold: boldface the crossreference text
  ## ref: append the citation of the concept definition (clause number, for local definitions)
  ## linkmention: use renderterm as the cross-reference text; if false, leave the cross-reference as is, to be resolved
  ## as is normal for Presentation XML
  ## linkref: cross-reference the citation of the concept definition to the source of that definition
  ## (same destination as linkmention). If false, unwrap the cross-references, and use only their text, with no cross-referencing
  ## e.g. 
  ##    <concept><refterm>term123</refterm> <renderterm>Term</renderterm> 
  ##       <eref bibitemid="ISO712" type="inline" citeas="ISO 712"/></concept>
  ## becomes
  ##    <em>Term</em> (<xref type="inline" target="ISO712">ISOÂ 712</xref>)
  ( 
     ## Link to a definition of the term in a bibliographic entry
     eref |
     ## Stack of links to a definition of the term in a bibliographic entry
     erefstack |
     ## Link to a definition of the term in an element of the current document
     xref |
     ## Link to a definition of the term in a termbase
     termref
  )
}

## UNWRAP: replace <related> with the crossreference to the term being related to
related =
  ## paragraph is: 
  ##    <p><strong>{related/@type}:</strong> <em>{related/preferred}</em> 
  ##       ({related/xref | related/eref | related/termref})</p>
  ## e.g.
  ##    <related type='contrast'><preferred><expression><name>Fifth Designation</name></expression></preferred>
  ##       <xref target='second'/></related>
  ## becomes: 
  ##    <p><strong>CONTRAST:</strong> <em><preferred><strong>Fifth Designation</strong></preferred></em> 
  ##       (<xref target='second'>Clause 1.1</xref>)</p>
  paragraph

erefAttributes =
    attribute normative { xsd:boolean }?,
    ## Regenerated, based on any potential flavour-specific rendering of the bibliographic citation
    attribute citeas { text },
    attribute type { ReferenceFormat }?,
    attribute alt { text }?

## UNWRAP: lists of erefs with @connective attributes are resolved to a single human-readable string of
## eref, with connectives linking them; e.g. 
##    <erefstack><eref connective="from" target="A"/><eref connective="to" target="A"/></erefstack>
## becomes
##    from <eref connective="from" target="A"/> to <eref connective="to" target="A"/>
erefstack = (
  element eref { erefTypeWithConnective } |
  text
)+

## UNWRAP: lists of locality with @connective attributes are resolved to a single human-readable string of
## locality, with connectives linking them; e.g. 
##    <eref bibitemid="ISO712" type="inline" citeas="ISO 712">
##      <localityStack connective="and">
##        <locality type='clause'><referenceFrom>3.1</referenceFrom></locality>
##      </localityStack>
##      <localityStack connective="and">
##        <locality type='figure'><referenceFrom>b</referenceFrom></locality>
##      </localityStack>
##    </eref>
## becomes
##    <locality type='clause'><referenceFrom>3.1</referenceFrom></locality> and <locality type='figure'><referenceFrom>b</referenceFrom></locality>
localityStack =
   element localityStack {
     ( locality | text )*
 }

## UNWRAP: as with localityStack
sourcelocalityStack =
   element sourcelocalityStack {
     ( sourcelocality | text )*
 }

## UNWRAP: locality becomes text; e.g.
##     <locality type='clause'><referenceFrom>3.1</referenceFrom></locality>
## becomes
##     Clause 3.1
## If eref/@droploc = true, do not insert the locality name. If eref/@case = capital, titlecase it. 
## If  eref/@case = lowercase, lowercase it
locality = text

## UNWRAP: as with locality
sourcelocality = text

## UNWRAP: convert eref to xref (pointing to bibliography anchor, xref/@target = eref/@bibitemid),
## or link (if a URI for the reference is supplied in the bibitem being referenced).
## The locality text (locality, sourcelocality), if present, is inserted as part of the cross-referenced text.
## If the locality is an anchor, and the eref is converted to link, append the anchor to the URI.
## If there is no text in the Semantic XML eref, it is populated with eref/@citeas
eref =
  xref | hyperlink

## UNWRAP: as for eref
origin =
  xref | hyperlink

## UNWRAP: as for eref
quote-source =
  xref | hyperlink

## UNWRAP: Append to blockquote attribution paragraph, containing formatted rendering of author and source
QuoteBody &=
    quote-attribution

## UNWRAP: Append to blockquote attribution paragraph, containing formatted rendering of author and source
QuoteNoIdBody &=
    quote-attribution

## Blockquote attribution paragraph, containing formatted rendering of author and source
quote-attribution = element attribution  {
    attribution-para
}

## TODO this is not a great pattern, we will want these inline Semantic XML elements to be spans pointing to their Semantic XML origin
attribution-para = element p {
  TextElement* & quote-author & quote-source
}

## TODO the same has been done for term definitions: we are inserting domain as a Semantic XML into the first definition
## paragraph, rather than leaving that to the renderer. In the future, we will make that instead a span with class fmt-domain,
## pointing to the source domain element. I'm not updating the grammar for now, because it would be nightmarish to and will not persist.
termdefinition &= empty
  
quote-source =
  element source { erefType }

quote-author =
  element author { text }

## Move svg to image/svg, for consistency.
## If image contains Data URI-encoded SVG, make it image/svg with explicit SVG markup.
## If the image is EPS, convert it to SVG.
## If the image is SVG, convert it to EMF, and add that as a separate child along SVG (for use by Word).
## If the image is EMF, convert it to SVG, and add that along the img/src EMG (for use outside of Word)
image = element image { 
    RequiredId,
    ImageAttributes,
     element svg {
       ( text | AnyElement )+
     }?,
     element emf { AnyElement }?
}

## UNWRAP: the links in svgmap are already resolved in standoc postprocessing, so they need not be retained
svgmap = figure

## If the xref is empty, it is resolved to the computed cross-reference label for the element being pointed to.
## xref/@case, xref/@droploc, xref/@style, xref/@label are used in computing the label.
## <location>, the locations within the reference being specified, are combined and  resolved into text appended to the body, 
## and removed as an element
XrefBody = PureTextElement+

## If the eref is empty, it is resolved to the citation of the bibliographic element being pointed to.
## <location>, the locations within the reference being specified, are resolved into text appended to the body, and removed as an element
ErefBody = PureTextElement+

## change identifier of requirement to just monospace
reqtlabel = tt

passthrough_inline = element passthrough { 
  ## @formats is made mandatory, populated with "all" if missing, and brought in line with the permitted output formats
  ## for the current flavour
  attribute formats { text },
  (text | AnyElement)+
}

passthrough = element passthrough {
  ## Format of markup to be transferred, comma-delimited
  ## @formats is made mandatory, populated with "all" if missing, and brought in line with the permitted output formats
  ## for the current flavour
  attribute formats { text }?,
  (text | AnyElement)+
} 

ruby = element ruby { 
  ## text content of ruby, or recursing of ruby
  element rb { text | ruby },
  ## content of Semantic XML ruby/pronunciation or ruby/annotation
  element rt { text }
}   

sections = 
  ## For most flavours, insert initial typed paragraphs to repeat the document title at the start of `sections`
  paragraph*,
  ## When the flavour displays normative references among the main section clauses, we move it to /sections/references
  ## from /bibliography/references
  ( clause | terms | term-clause | definitions | floating-title |
    references
  )+

## In references listings, bibliographic entries typicaly have either the document identifier or an ordinal number
## prefixed to them, depending on SDO style. biblio-tag identifies which if any identifier(s) will precede the bibliographic entry,
## and marks them up as a separate tag.
## The biblio-tag may be footnoted with information about its draft status, if so required by the SDO;
## that is extracted from bibitem/note[@type = 'Unpublished-Status'] or bibitem/docidentifier/fn
biblio-tag = element biblio-tag { text, fn?, tab? }

## The user-supplied Semantic XML title (if any) is given a unique ID number for cross-referencing.
## 
## It is followed by a Presentation XML-specific fmt-title, which is derived from the Semantic XML title,
## and adds to it autonumbering. fmt-title indexes the title it is derived from.
## Titles missing in the Semantic XML for forewords and definitions are populated here.
##
## The default cross-reference text for the clause is then given
section-title =
  element title {
    attribute id { xsd:ID },
    TextElement*
  }?,
  element variant-title { TypedTitleString }*,
  fmt-title,
  fmt-xref-label*

## All clause titles by default are prefixed by the i18n'd autonumbered label of the clause, where applicable,
## followed by a delimiter (as dictated by the house style). Autonumbers are given in <semx/>, and the content
## of fmt-title is annotated with spans of class fmt-*, as described under <span>
## e.g. 
##     <clause id="A">
##     <title>Discussion</title>
## becomes
##     <clause id="A">
##     <title id="A1">Discussion</title>
##     <fmt-title depth="1" source="A1">
##       <span class="fmt-caption-label">
##         <span class="fmt-element-name">Clause</span> <semx element="autonum" source="A">4</semx>
##       </span><span class="fmt-autonum-delim">.</span><span class="fmt-caption-delim"><tab/></span>
##       <semx element="title" source="A1">Discussion</semx>
##      </fmt-title>
## Annex titles also usually include indication of the annex obligation (span[@class = 'fmt-obligation']).
## If no title is present in the Semantic XML, fmt-title is generated without the title caption (semx[@element = "title"])
## and the caption delimiter (span[@class="fmt-caption-delim]); span[@fmt-autonum-delim] is still added
## (so "Clause 4*.*", if the flavour requires it, but not "Clause 4.*<tab/>*".)
## No fmt-caption-label is added for clauses with @unnumbered = true, or if the document processing directive is to drop heading numbers
## (e.g. ISO Amendments). No fmt-caption-label is added for single special clauses in annexes:
## //annex/terms and //annex/references are a Terms or References section put in an annex, and they are not labelled
## separately from the containing annex. 
## Top-level section titles in CJK 3 characters or less in size are rendered extended 
fmt-title = element fmt-title {
    ## A hierarchical section title is given an explicit count of its nesting depth, as a hint for rendering
    attribute depth { xsd:integer }?,
    ## The ID of the title that the fmt-title is derived from
    attribute source { xsd:IDREF }?,
    TextElement*
  }

## The default cross-reference text for the element; for example, "Clause 1" for a clause.
## This text may be different from the caption for the element; for example, ISO labels notes as "NOTE 1",
## but cross-references them as "note 1". 
fmt-xref-label = element fmt-xref-label {
  ## Some assets have a different default cross-reference based on whether they are inside or outside of a container element;
  ## for instance, because note numbering restarts in most flavours each clause, a Note may be referenced as "Note 1"
  ## within Clause 2, but as "Clause 2, Note 1" outside of Clause 2. These cross-references are differentiated by
  ## using the container attribute to point to that container element. If two fmt-xref-label elements are provided,
  ## one with a container attribute, and one without, then any cross-references from a descendant of the container node 
  ## will use the latter element for its text, and any cross-references from outside the container node will use the former:
  ##  <fmt-xref-label container="A">Clause 2, Note 1</fmt-xref-label> # used outside of A; "Clause 2" is itself element A.
  ##  <fmt-xref-label>Note 1</fmt-xref-label> # used within A
  attribute container { xsd:IDREF }?,
  ## The cross-reference text is semantically annotated with span[@class='fmt-*'] and semx, as for captions;
  ## refer to those elements for definitions.
  TextElement*
}

## Semantic XML floating-title has a paragraph added after it, of type "floating-title".
## The content of floating-title is replicated to p[@type = 'floating-title'] as semx[@element = 'floating-title'].
## Top-level section titles in CJK 3 characters or less in size are rendered extended 
floating-title &= paragraph

term = element term {
    OptionalId,
    LocalizedStringAttributes,
    BlockAttributes,
    ## Clause number of term
    tname,
    ## UNWRAP: Consecutive preferred designations are concatenated into a single designation, delimited by semicolon,
    ## if they are both verbal designations, in the same language and locale, and neither has pronunciation or grammar information
    preferred+,
    ## In some flavours, admited designations are prefixed with the i18n of "ADMITTED:"
    admitted*,
    ## Deprecated designations are prefixed with the i18n of "DEPRECATED:"
    deprecates*,
    related*,
    termdomain?,
    termsubject?,
    ## UNWRAP: multiple termdefinitions are replaced with a single definition, consiting of an ordered list of definitions
    termdefinition,
    termnote*,
    termexample*,
    TermSource
}

## Indicate that domain display is to be suppressed if it is being rendered inside of a definition
## TODO will rescind that and put in a pattern that crossreferences rendered Semantic XML elements and their original
termdomain &=
  attribute hidden { xsd:boolean }

## UNWRAP: The designation is replaced with a string concatenating its data:
## The designation name, then field-of-application and usage-info comma-delimited and in angle brackets,
## then expression/grammar information comma-delimited, then language, script and locale comma-delimited,
## then expression/pronunciation comma-delimited and in slashes.
## Bookmarks inside the designation are removed. Preferred designations are boldfaced.
## Any termsources within the designation are moved after it
Designation = 
  attribute absent { xsd:boolean }?,
  attribute geographic-area { text }?,
  PureTextElement+

## UNWRAP: remove verbaldefinition wrapper
verbaldefinition =
    (paragraph | dl | ol | ul | table | figure | formula)+,
    TermSource

## UNWRAP: remove nonverbalrep wrapper
nonverbalrep =
    ( table | figure | formula )+,
    TermSource

DisplayOrder =
  ## The top-level clauses and blocks of the document are numbered in the order in which they should be rendered,
  ## taking floating titles into account.
  ## Rendering follows that ordering, rather than the ordering of claues in the XML
  attribute displayorder { xsd:int }

}
# end overrides

## Clauses in the preface are rearranged into canonical order.
## An initial table of contents placeholder is inserted at the start of the preface by default, as
##    <clause type="toc"><title depth="1">{ i18n of 'Table of contents' }</title></clause>
## If the flavour requires them, additional placeholders are inserted for tables of figures, tables, requirements
preface &= empty

## Any instances of xref in a pre-populated table of contents are prefixed with the clause number they are referencing
toc &= empty

SourceBody |=
  tname?,
  (
    ( text | callout )+ |
    ## UNWRAP: Source code rendered with source highlighting, as a table of line numbers and source code;
    ## the source code is rendered as with sourcecode within table cells
    table |
    ## UNWRAP: The source-highlighted sourcecode within the table cell uses span elements to semantically classify the keywords, 
    ## and the span tags are coloured through the supplied source-highlighter-css
    ( text | callout | span )+
  ),
  ## UNWRAP: annotations are replaced by a definition list
  dl?,
  note*

PureTextElement |= tab

## All strings in table cells are broken up if they exceed a threshold of length
## (20 chars), in order to allow table cells not to be artificially widened
TdBody &= empty

## Any instances of pseudocode figures are processed as sourcecode is.
## If figure is labelled with figure/@class (e.g. "diagram"), use the i18n of figure/@class, rather than "Figure",
## to label the figure
##
## By default, any footnotes of the figure are moved to the beginning of the Figure key: the definition term is
## the footnote reference, the definition content is the footnote content. This follows ISO rendering, and presupposes
## that the footnote reference is embedded in the figure graphically.
##
## If not supplied, a label paragraph is given for the key. TODO: this should be dl/name throughout, not p
figure &= empty

## UNWRAP: Dates marked up with value and format are converted into an i18n'd rendering of the date
date_inline |= text

## <span> with @style=text-transform... is converted into case-transformed text (rather than leaving that to CSS).
## <span> with @custom-charset= is converted to include font markup in @style appropriate to that charset
##
## <span> with classes prefixed with "fmt-" are used to annotate semantically content introduced in Presentation XML.
## In particular:
## * fmt-element-name is an element name (or other name of an asset type), used to label an autonumbered asset
## (block or clause) in a caption and in a cross-reference. For example, *Table* 1, *Drawing* 3, *Annex* A.
## This name is i18n'ised, as appropriate (e.g. *Tableau* 1 in French).
## * fmt-caption-label is used to annotate the autonumber label for an asset in captions.
## For example, *Table 1*, *Drawing 3*, *Annex A*. The fmt-caption-label span is differentiated from a following
## user-supplied title, e.g. "*Table 1*: After-effects of plutonium." It typically consists of an asset type name
## (span[@class = 'fmt-element-name']) plus an autonumber (semx).
## * fmt-caption-delim is used to annotate punctuation or space delimiting the  autonumber label (fmt-caption-label) from
## any user-supplied title of the asset, e.g. "Table 1*:* After-effects of plutonium.",
## "Clause 3*<tab/>*Discussion".
## * fmt-label-delim is used to annotate puncutation or space inserted after the autonumber label and any user-supplied title,
## e.g. "Table 1: After-effects of plutonium*.*" (at the end of a table caption), 
## or "Note 3*:<tab/>* The after-effects are outlined above." (the delimiter separates the note label from note content,
## and would follow any note title if one were given.) The sequence in a caption is thus 
## (with <semx element='autonum'/> the autonumber itself, and <semx element='name/title'> the user-supplied title):
##
## <fmt-caption-label><fmt-element-name/> <semx element='autonum'/></fmt-caption-label><fmt-caption-delim/>
##   <semx element='name'><fmt-label-delim/>
## * fmt-autonum-delim is used to separate numbers in a hierarchy, when an autonumber is built up of other numbers;
## e.g. Clause 2*.*1, Figure 1*-*2. It is also used for punctuation surrounding an autonumber (as opposed to separating it
## from a following user-supplied caption; e.g. Formula *(*2*)*, Figure 1 a*)*.
## The numbers it separates will typically be <semx class='autonum'/>
## * fmt-xref-container is used in cross-references, to indicate the label of an ancestor node of the target node,
## used to disambiguate the cross-reference to that node. For example, notes are typically renumbered each clause,
## so "Note 1" is ambiguous in a cross-reference outside the current node; the cross-reference will instead be generated
## as "*Clause 5*, Note 1". "Clause 5" is annotated as fmt-xref-container.
## * fmt-comma is used to annotate a comma used as a delimiter for autonumbers, especially between fmt-xref-container
## and the cross-reference proper, e.g. "Clause 5*,* Note 1". 
## * fmt-enum-comma  is used for commas introduced in auto-generated enumerations, such as Boolean conjunctions of 
## more than two cross-references, e.g. "Clauses 2*,* 3 and 5".
## * fmt-conn is used to annotate Boolean conjunctions introduced in auto-generated text, such as of multiple cross-references,
## e.g. "Clauses 2, 3 *and* 5".
## * fmt-obligation is used to annotate the indication of obligation in annex titles ("normative", "informative").
span &= empty

## UNWRAP: Number formatting is applied to stem/mathml expressions: inline stem, and if number formatting is specified 
## (@data-metanorma-numberformat), ## formula/stem/mathml as well. 
## If the stem expression is MathML consisting only of mn, it is replaced with the text content of mn,
## to reduce processing load. If the stem expression does not already contain <asciimath>,
## an Asciimath version of the MathML is added, for human readability and potential round-tripping.
## If the attribute @linebreak is present in the MatML, two different MathML expressions are generated:
## math-no-linebreak, containing the original MathML, and math-with-linebreak, which breaks the source MathML
## expression up into separate MathML expressions, joined by <br/>: this is to enable correct rendering in Word.
## If the MathML has <strong> as an ancestor, <mstyle mathvariant="bold"> is wrapped around the MathML contents:
## this is because the PDF rendering is not dealing with boldfacing MathML when its container is boldface.
stem |= text

metanorma-source-container = element metanorma { metanorma-source }

## When all bibitem children of references have @hidden = true, set @hidden = true on references
## as well: this suppresses display of the entire clause (including title and boilerplate)
ReferencesAttributes &=
    attribute hidden { xsd:boolean }?

## All bibliographic entries are rendered through relaton-render, which applies the Metanorma flavour's
## citation stylesheet to populate bibitem/formattedref, according to bibitem/@type. (Different bibliographic types
## have different rendering templates.) Do not populate formattedref if it is already supplied, and there is no title
## (to indicate that there is semantic information present: i.e. formattedref is supplied, and cannot be overwritten
## based on semantic elements). If populating formattedref, strip most other semantic element of bibitem as no longer
## relevant; by default, retain docidentifier, uri, note, biblio-tag.
## If bibitem/@suppress_identifier = true, all bibitem/docidentifier are stripped prior to rendering.
## If bibitem/@type is empty, set it to "standard".
## If bibitem belongs to a class of implicit references defined for the flavour (e.g. IEV references for ISO),
## mark it as @hidden = true.
## If bibitem belongs to a bibliography (informative references), by default we assume it to be numbered:
## if it is, insert <docidentifier type = 'metanorma-ordinal'>[{ordinal number}]</docidentifier> to provide the number,
## and renumber all such references from 1.
doc_bibitem &= biblio-tag?
  
## Depending on the flavour, the docidentifier type for references is prefixed to the docidentifier contents, as its
## publisher indicator, for disambiguation; e.g. 
##    <docidentifier type="IETF">I.-D. Arthur</docidentifier>
## becomes
##    <docidentifier type="IETF">IETF I.-D. Arthur</docidentifier>
docidentifier &= empty
  
## UNWRAP: Requirements may be rendered arbitrarily depending on the requirements model; in the case of Modspec,
## they are rendered as tables. Requirements are labelled with requirement/@class, or according to their element name
## if requirement/@class is absent, just as with figures
RequirementType |= BasicBlock+

## Document title in metadata, in CJK 3 characters or less in size, is rendered extended 
btitle &= empty

## If this is a single special clause in an annex (terms, or references), then this is a Terms or References section put in an annex,
## and it is not treated as a distinct subclause from its parent; if the annex has no distinct title, use the special clause title instead.
## Adjust title/@depth accordingly
annex-subsection &= empty

## Any termsources within the designation are moved after it
preferred &= TermSource

## Any termsources within the designation are moved after it
admitted &= TermSource

## Any termsources within the designation are moved after it
deprecates &= TermSource

## In some flavours, the index section is not rendered.
## In others, e.g. ISO, it is populated with a list of cross-references, each representing an index entry
indexsect |= empty

## In flavours which do not support indexes, index terms are deleted
index |= empty
  
## In flavours which do not support indexes, index cross-references are deleted
index-xref |= empty

Basic-Section-Attributes &= DisplayOrder

## If a block occurs at top level of the document (e.g. initial admonition, repetition of title at start of `sections`,
## it gets a displayorder attribute
BlockAttributes &= DisplayOrder


## The metanorma-source element contains a copy of the Semantic XML, so that downstream
## consumers can process Semantic XML and Presentation XML in tandem. The Semantic and
## Presentation XML are aligned as follows, in order to avoid duplicate references and
## to segregate the embedded XML from processing:
##
## * Each element in metanorma-source is prefixed with semantic__ : <semantic__p>
## * Any namespaced element has semantic_ prefixed to its name : <mathml:semantic__math>
## * The root namespace of the embedded Semantic XML is stripped : <semantic__iso-document> (no ns)
## * Every attribute of the Semantic XML that is an identifier (id, name) is prefixed with semantic__ :
##   <semantic__p id="semantic__A123">
## * Every attribute of the Semantic XML that references an element identifier is prefixed with semantic__ :
##   <semantic_xref target="semantic__A123">
metanorma-source = element metanorma { AnyElement+ }
