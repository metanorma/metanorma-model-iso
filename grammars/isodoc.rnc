grammar {

# ALERT: cannot have root comments, because of https://github.com/metanorma/metanorma/issues/437
#
# instantiations of this grammar may replace leaf strings
# with more elaborated types; e.g. title (text) replaced with
# title-main, title-intro, title-part; type replaced with
# enum.
#
# some renaming at leaf nodes is permissible
#
# obligations can change both from optional to mandatory,
# and from mandatory to optional; optional elements may
# be omitted; freely positioned alternatives may be replaced
# with strict ordering
#
# DO NOT introduce a namespace here. We do not want a distinct namespace
# for these elements, and a distinct namespace for any grammar inheriting
# these elements; we just want one namespace for any child grammars
# of this.

include "reqt.rnc" { }

include "basicdoc.rnc" { 

## Block expressing a machine-readable change in a document
amend = element amend {
  RequiredId,
  BlockAttributes,
  AmendType,
  ## Specification of how blocks of a given class should be autonumbered within an AmendBlock newContent element
  autonumber*
}

## Cross-references are not normalised to xsd:IDREF in Semantic XML: that is deferred to Presentation XML.
## All IdRefType instances point not to `@id` in Semantic XML, which is the Content GUID for an element,
## but to `@anchor`, the user-supplied cross-reference
IdRefType = text

index-primary = element primary { (PureTextElement|stem)+ }
index-secondary = element secondary { (PureTextElement|stem)+ }
index-tertiary =  element tertiary { (PureTextElement|stem)+ }

## Title(s) of a clause
section-title =
  ## Title proper for a clause
  element title { TextElement* },
  ## Alternate title for a clause
  element variant-title { TypedTitleString }*

UlBody =
    ## Caption of list
    tname?,
    ## List items
    ul_li+,
    ## Notes whose scope is the current block
    note*

OlBody =
    ## Caption of list
    tname?,
    ## List items
    li+,
    ## Notes whose scope is the current block
    note*

## NOTE: `start` attribute is not included by default, because of problems it raises with DOC output
OlAttributes =
    BlockAttributes,
    ## Type of numbering to be applied to the list items
    attribute type { ( "roman" | "alphabet" | "arabic" |
                       "roman_upper" | "alphabet_upper" ) }?

DlAttributes =
    BlockAttributes,
    ## This definition list is the key of a figure or formula
    attribute key { xsd:boolean }?

DlBody =
    ## Caption of the list
    tname?,
    ## Entry-Definition pair used to constitute a definition list
    (
      ## Entry being defined in the definition
      dt,
      ## Definition of the entry
      dd
    )+,
    ## Notes whose scope is the current block
    note*

dt =
  element dt { 
    ## Optional identifier for definition term (enabling crossreferencing of definitions)
    OptionalId,
    ## Entry being defined in the definition
    TextElement*
  }

ExampleAttributes =
    NumberingAttributes,
    BlockAttributes

ExampleBody =
    ## The caption of the example
    tname?,
    ## Content of the example
    ( formula | ul | ol | dl | quote | sourcecode | paragraph-with-footnote | figure )+,
    ## Notes whose scope is the current block
    note*

TableBody =
    ## The widths of the columns in the table
    colgroup?,
    ## Caption for the table
    tname?,
    ## Table rows constituting the table header
    thead?,
    ## Table rows constituting the table body
    tbody,
    ## Table rows constituting the table footer
    tfoot?,
    ## Definitions list defining any symbols used in the table
    dl?,
    ## Notes specific to this block
    table-note*,
    ## A source for the table
    BlockSource

SourceBody =
    ## The caption of the block
    tname?,
    ## The sourcecode content
    sourcecodebody,
    ## Annotations to the source code; each annotation consists of zero or more paragraphs,
    ## and is intended to be referenced by a callout within the source code
    annotation*,
    ## Notes whose scope is the current block
    note*,
    ## A source for the block
    BlockSource

FigureBody =
     ## The caption of the block
     tname?,
     ## Content of the figure
     (image | video | audio | pre | paragraph-with-footnote+ | figure*),
     ## Footnotes specific to the figure
     fn*,
     ## An optional definitions list defining any symbols used in the figure
     dl?,
     ## Notes whose scope is the current block
     note*,
     ## A source for the block
     BlockSource

FigureNoIdBody =
     ## A URI or other reference intended to link to an externally hosted image (or equivalent)
     source?,
     ## The caption of the block
     tname?,
     ## Content of the figure
     (image-no-id | video-no-id | audio-no-id | pre-no-id | paragraph-with-footnote-no-id+ | figure-no-id*),
     ## Footnotes specific to the figure
     fn*,
     ## An optional definitions list defining any symbols used in the figure
     dl-no-id?,
     ## Notes whose scope is the current block
     note-no-id*,
     ## A source for the block
     BlockSource

source = element source {
    ## The status of the term as it is used in this document, relative to its definition in the original document
    attribute status { SourceStatusType },
    ## The type of the managed term in the present context
    attribute type { SourceTypeType },
    ## The original document and location where the term definition has been obtained from
    origin,
    ## Any changes that the definition of the term has undergone relative to the original document,
    ## in order to be applicable in this standardisation document
    modification?
}

## The computer code or other such text presented in the block, as a single unformatted string. 
## (The string should be treated as pre-formatted text, with whitespace treated as significant)
sourcecodebody = element body {
(   
       text |
       ## Zero or more cross-references; these are intended to be embedded within the content string, and link to annotations
       callout |
      ## Hyperlink of code segment to another part of the document
      xref |
      ## Hyperlink of code segment to external bibliographic resource
      eref
    )+
}

sections =
  element sections {
    ( clause | terms | term-clause | definitions | floating-title )+
}

## Bibliography clause. It is used to collate references within the document, where
## there could be one or more of such sections within a document. For example, some standardization documents differentiate
## normative or informative references, some split references into sections organized by concept relevance.
references =
  element references {
    OptionalId,
    ReferencesAttributes,
    section-title?,
    ## Prefatory text
    BasicBlock*,
    (
      ## Bibliographic item cited in the document
      doc_bibitem,
      ## Annotation of the bibliographic item
      note*)*,
    ## Recursive references section
    references*
}

## Content of note
NoteBody =
    (paragraph-with-footnote | ul | ol | dl | formula | quote | sourcecode)+

## Group of blocks within text, which is a leaf node in the hierarchical organisation of text (does not contain any sections of its own)
Basic-Section =
    Basic-Section-Attributes,
    ## Title of the section
    section-title?,
    ## Blocks, containing the textual content of the section
    ## (but excluding subsections, which are only present in Hierarchical Sections)
    (BasicBlock+)

LiBody =
    BasicBlock+
    # exclude figures?

dd =
  element dd {
    # exclude figures?
    BasicBlock*
  }

thead = element thead { tr+ }

TdBody =
    (
      ## Table cell is a block
      (TextElement | fn )* |
      ## Table cell contains a block
      (paragraph-with-footnote | dl | ul | ol | figure)+
    )

ThBody =
    (
      ## Table cell is a block
      (TextElement | fn )* |
      ## Table cell contains a block
      paragraph-with-footnote+
    )

TrAttributes =
  ## CSS style: only background-color supported
  attribute style { text }?

table-note = element note {
    OptionalId,
    paragraph-with-footnote+
}

## Subscript text. Corresponds to HTML `sub
sub = element sub { (PureTextElement|stem)* }

## Superscript text. Corresponds to HTML `sup`
sup = element sup { (PureTextElement|stem)* }

## Page break. Only applicable in paged layouts (e.g. PDF, Word), and not flow layouts (e.g. HTML)
pagebreak = element pagebreak { 
  ## Orientation of pages in a section of text in paged media following this page break, applicable until the next page break that
  ## gives an explicit page orientation
  attribute orientation { "landscape" | "portrait" }?
}

XrefBody =
     ## Description of location in a reference, which can be combined with other locations in a single citation
     XrefTarget*,
     ## The textual content of the element. The `text` is what we wish to show the link as (e.g., the "content" of `<xx>my link text</xx>`)
     element display-text { PureTextElement+ }?

}

# end overrides

FnAttributes &=
    ## If true, number the footnote as normal, but suppress display of the footnote reference in the document body.
    ## This is done if the footnote reference is already presented in some other form, e.g. within a figure image.
    attribute hiddenref { xsd:boolean }?

TdAttributes &=
  ## CSS style: only background-color supported
  attribute style { text }?

NumberingAttributes &=
    ## Override the numbering of this block in numbering
    attribute number { text }?

AdmonitionAttributes &=
    ## Display the admonition on the document cover page
    attribute coverpage { xsd:boolean }?,
    ## Do not insert text labelling the type of admonition in rendering
    attribute notag { xsd:boolean }?

AdmonitionType |=
  ## Intended for typographically separate statements in mathematics, such as propositions, proofs, or theorems. Statement conflates all of these for rendering, while Proposition, Proof, Theorem etc. can be treated as distinct classes
  "statement" |
  ## Annotation by document editors, intended for all readers of the document and not just its authors
  "editorial" |
  ## Box annotation, intended as standalone sidebar element which can be referenced from within the document
  "box"

HyperlinkAttributes &=
    ## Update link file suffix to match rendered file output (HTML > HTML, PDF > PDF)
    attribute update-type { xsd:boolean }?,
    ## Style of hyperlink rendering
    attribute style { text }?

erefAttributes &=
    ## Casing of the autogenerated label of the cross-reference (typically the name of the class of element referenced):
    ## titlecase, or lowercase
    attribute case { "capital" | "lowercase" }?,
    ## Do not include the autogenerated label of the cross-reference in rendering
    attribute droploc { xsd:boolean }?,
    ## Style of how a citation is to be rendered
    attribute style { text }?

UlAttributes &=
    BlockAttributes

TableAttributes &=
    ## Width of the table block in rendering
    attribute width { text }?,
    BlockAttributes

FigureAttributes &=
    ## Width of the figure block in rendering
    attribute width { text }?,
    BlockAttributes

SourceAttributes &=
    BlockAttributes,
    ## Render the sourcecode block with line numbering. Default value is false
    attribute linenums { xsd:boolean }?

FormulaAttributes &=
    BlockAttributes

ParagraphAttributes &=
    ## Semantic classification of paragraph
    attribute type { text }?,
    BlockAttributes

QuoteAttributes &=
    BlockAttributes

NoteAttributes &=
    ## Semantic classification of note
    attribute type { text }?,
    ## Display the note on the document cover page
    attribute coverpage { xsd:boolean }?,
    ## Do not insert text labelling the note as a note in rendering
    attribute notag { xsd:boolean }?,
    BlockAttributes

StemAttributes &=
    ## Numeric formatting directives to apply to mathematically formatted text
    attribute number-format { text }?,
    ## Whether to treat the expression as a block or as an inline element, for display purposes
    attribute block { xsd:boolean }

XrefAttributes &=
     ## If the cross-reference is to a range of text defined as a span between two identified elements,
     ## provide the identifier of the end element of the span
     attribute to { xsd:string { pattern = "\i\c*|\c+#\c+" }}?,
     ## Casing of the autogenerated label of the cross-reference (typically the name of the class of element referenced):
     ## titlecase, or lowercase
     attribute case { "capital" | "lowercase" }?,
     ## Do not include the autogenerated label of the cross-reference in rendering
     attribute droploc { xsd:boolean }?,
     ## Style of cross-reference rendering (title vs numbering)
     attribute style { XrefStyleType }?,
     ## Substitute the expected label of the item being cross-referenced with a custom label (e.g. "subclause" instead of "clause")
     attribute label { text }?

Basic-Section-Attributes &=
    attribute obligation { ObligationType }?

RequiredId &=
    ## User-supplied anchor of element; replaced by content-based id, with all references to the anchor updated accordingly
    attribute anchor { text }?

OptionalId &= 
     ##  User-supplied anchor of element; replaced by content-based id, with all references to the anchor updated accordingly
    attribute anchor { text }?


## The force of a clause in a standard document: whether it has normative or informative effect
ObligationType = "normative" | "informative"

## Standardisation document representation of bibliographic entry
doc_bibitem =
  element bibitem {
     RequiredId,
     ## Suppress from dislay in rendered document
     attribute hidden { xsd:boolean }?,
     ## Suppress document identifier from item rendering
     attribute suppress_identifier { xsd:boolean }?,
     ReducedBibliographicItem
}


image |=
  ## Add svg mark up to image
  element svg {
     ( text | AnyElement )+
}

BasicBlock |= columnbreak

## Indication of a break in text rendered as columns
columnbreak = element columnbreak { empty }

## How a block element may be rendered in a multilingual document, with a column for each language
MultilingualRenderingType =
  ## Block is shared across all languages
  "common" |
  ## Block spans all columns of text, and versions in different languages are displayed consecutively
  "all-columns" |
  ## Block is to be aligned to the block occupying the same position in the document hierarchy
  "parallel" |
  ## Block is to be aligned to all blocks sharing the same `tag` attribute as this block
  "tag"

colgroup = element colgroup { col+ }

col = element col {
    ## The width of an individual table column
    attribute width { text }
}

BibItemType |= 
  ## Internal reference (for Metanorma document collections)
  "internal"

TextElement |= concept | add | del | span | erefstack | date_inline

PureTextElement |= passthrough_inline

NestedTextElement |= erefstack

## Inline text not to be processed semantically, and left in the markup of a target rendering language (e.g. raw HTML)
passthrough_inline = element passthrough {
  ## List of the target formats for which the markup is intended, comma-delimited
  attribute formats { text }?,
  ## Markup specific to a target rendering language
  (text | AnyElement)+
}

## Indication of text added through editorial intervention
add = element add { NestedTextElement* }

## Indication of text deleted through editorial intervention
del = element del { NestedTextElement* }

## Semantic or formatting markup for inline elements
span = element span {
  ## Class of the inline span, as semantic markup
  attribute class { text }?,
  ## CSS style directive for the inline span. Is intended to be the same as HTML style attribute
  attribute style { text }?,
  ## Character set that the contained text belongs to; 
  ## is used in particular to capture mutually agreed definitions of codepoints in Unicode Private Use Area
  attribute custom-charset { text }?,
  ## Textual content of span
  TextElement+
}

## Localisable rendering of a date
date_inline = element date {
  LocalizedStringAttributes,
  ## Date to be rendered, in ISO 8601 format
  attribute value { xsd:dateTime },
  ## Format to be used to render date, as a strftime formatting string
  attribute format { text }?
}

## Formally defined concept used in a standardisation document, aligned to a definition.
## That concept may be defined as a term within the current document, or it may be defined externally
concept = element concept {
  ## Render the term in the concept in boldface
  attribute bold { xsd:boolean }?,
  ## Render the term in the concept in italics
  attribute ital { xsd:boolean }?,
  ## Render a reference to a definition for the concept, e.g. "widgets (3.1)"
  attribute ref { xsd:boolean }?,
  ## Hyperlink the mention of the term to the definition for the concept
  attribute linkmention { xsd:boolean }?,
  ## Hyperlink the reference for the term to the definition for the concept
  attribute linkref { xsd:boolean }?,
  ## The canonical name of the concept being defined
  element refterm { (PureTextElement|stem|index|index-xref)* }?,
  ## The rendering to be used for the concept
  element renderterm { (PureTextElement|stem|index|index-xref)* }?,
  ( 
     ## Link to a definition of the term in a bibliographic entry
     eref | 
     ## Stack of links to a definition of the term in a bibliographic entry
     erefstack | 
     ## Link to a definition of the term in an element of the current document
     xref | 
     ## Link to a definition of the term in a termbase
     termref 
  )
}

BasicBlock |= requirement | recommendation | permission | imagemap | svgmap | inputform | toc | passthrough

## Table of contents, represented as a list of crossreferences, each with textual content
toc = element toc {
   ## List of crossreferences
   ( ul )
}

## Wrapper around raw markup to be transferred into one or more nominated output formats during processing
passthrough = element passthrough {
    ## Format of markup to be transferred, comma-delimited
    attribute formats { text }?,
    ## Markup to be transferred
    (text | AnyElement)+
}

## Input form, for use under HTML
inputform = element form {
    RequiredId,
    ## Name of the input form block
    attribute name { text },
    ## Action to be taken on submission of the input form
    attribute action { text },
    ## Class of input form
    attribute class { text }?,
    BlockAttributes,
    # Input form contents
    ( TextElement | FormInput | formlabel )*
}

## Input element for forms, associated with name/value pair to be submitted
FormInput = input | select | textarea

FormInputAttributes =
    ## Name of value of input element to be submitted
    attribute name { text }?,
    ## Preset or default of value of input element to be submitted
    attribute value { text }?

## Type of simple Input element
InputType =
  ## Input element is a button
  "button" |
  ## Input element is a checkbox
  "checkbox" |
  ## Input element contains date
  "date" |
  ## Input element selects file for upload
  "file" |
  ## Input element is a password field
  "password" |
  ## Input element is a radio button
  "radio" |
  ## Input element is a submit button
  "submit" |
  ## Input element contains text
  "text"

## Input involving simple text
input = element input {
    ## Type of input element
    attribute type { InputType },
    ## Input element is checkbox, and has checked value
    attribute checked { xsd:boolean }?,
    ## Input element is disabled
    attribute disabled { xsd:boolean }?,
    ## Input element is read-only
    attribute readonly { xsd:boolean }?,
    ## Maximum length of input in characters, for character input
    attribute maxlength { xsd:int }?,
    ## Minimum length of input in characters, for character input
    attribute minlength { xsd:int }?,
    FormInputAttributes,
    OptionalId
}

## Label associated with form input element
formlabel = element label {
    # Identifier of form input element that this element is a label of
    attribute for { IdRefType },
    PureTextElement*
}

## Input allowing the selection of a value from a list of values. The value attribute is used instead of a selected
## attribute on a component option
select = element select {
    FormInputAttributes,
    OptionalId,
    ## Input is disabled
    attribute disabled { xsd:boolean }?,
    ## Input can return multiple option values
    attribute multiple { xsd:boolean }?,
    ## Suggested number of options to display
    attribute size { xsd:int }?,
    ## Options to select from as value of the input
    option+
}

## Option of a Select input
option = element option {
    ## Option is disabled
    attribute disabled { xsd:boolean }?,
    ## Value associated with this option
    attribute value { text }?,
    ## Display text associated with this option
    PureTextElement*
}

## Input involving extended text. The value attribute is used instead of text area content
textarea = element textarea {
    FormInputAttributes,
    OptionalId,
    ## Suggested number of rows for the input area
    attribute rows { xsd:int }?,
    ## Suggested number of columns for the input area
    attribute cols { xsd:int }?
}

## Bibliographic references
bibliography =
  element bibliography {
    (references | reference-clause)+
}

Section-Attributes =
    Basic-Section-Attributes,
    ## Render the section number and title (if present) inline with the first paragraph of the section
    attribute inline-header { xsd:boolean }?,
    ## Value of number to be used for numbering of section, overriding any autonumbering in rendering.
    ## The section number is still formed by appending this number to the hierarchical set of parent section numbers,
    ## e.g. a number "3a" under Clause 1 subclause 2 will be numbered as 1.2.3a
    attribute number { text }?,
    ## Value of number to be used for numbering of section, overriding any autonumbering in rendering,
    ## and the hierarchy of parent section numbers. This attribute is mutually exclusive with `number`.
    ## So under Clause 1 subclause 2, sub-subclause 3 is numbered as 1.2.3. If the following sub-subclause
    ## is given a branch-number "7.2.1.5", that will be the overall section number given, ignoring the parent section
    ## numbers
    attribute branch-number { text }?,
    ## Do not apply numbering to this clause
    attribute unnumbered { xsd:boolean }?

## References clause with recursive nesting
reference-clause =
  element clause {
    Section-Attributes,
    section-title?,
    ## Prefatory text
    BasicBlock*,
    ## Recursion of reference clauses
    (
       reference-clause+ | references*
    )
}

## Attributes on document root
Root-Attributes =
  ## Version number of the gem used to generate this document
  attribute version { text },
  ## Version number of the schema that this document is aligned to
  attribute schema-version { text },
  ## Type of standards document representation. "Semantic" is the core representation of content.
  ## "Presentation" manipulates and enhances the representation for rendering needs.
  attribute type { "semantic" | "presentation" },
  ## Metanorma flavor, indicating SDO whose requirements the realisation aligns to
  attribute flavor { text }

## Representation of a standardisation document
standard-document =
element metanorma {
  Root-Attributes,
  ## Bibliographic description of the document itself, expressed in the Relaton model
  bibdata, 
  ## Source for term definitions in the document
  termdocsource*, 
  ## Extension point for extraneous elements that need to be added to standards document as data
  misccontainer?, 
  ## Front matter that is repeated at the start of documents issued from an SDO, with content not specific to the document
  boilerplate?, 
  DocumentBody,
  ## Annotations to the document
  review-container?
}

DocumentBody =
  ## Prefatory sections
  preface?, 
  ## Main body of document
  sections, 
  ## Annex sections
  annex*, 
  ## Bibliographic sections
  bibliography?, 
  ## Index of the document
  indexsect*, 
  ## Colophon or postface material
  colophon?

## Elements added to metanorma-extension are open-ended, and constitute source data
misccontainer = element metanorma-extension { AnyElement+ }

review-container = element review-container { review+ }

preface =
  element preface { ( content | abstract | foreword | introduction | acknowledgements | executivesummary )+ }

colophon =
  element colophon { content+ }

## Foreword of document
foreword =
  element foreword { Content-Section }

## Introduction of document
introduction =
  element introduction { Content-Section }

executivesummary =
  element executivesummary { Content-Section }

indexsect = element indexsect { Content-Section }

## Content addressing legal and licensing concerns around the document, outside of the main flow of document content
boilerplate = 
  element boilerplate { 
     ## Preset templated text provided by the standardization body, describing the copyright status of the document
     copyright-statement?, 
     ## Preset templated text provided by the standardization body, providing the licensing terms for the document content
     license-statement?, 
     ## Preset templated text provided by the standardization body, providing the legal constraints and considerations around use of the document
     legal-statement?, 
     ## Preset templated text provided by the standardization body, providing information on where feedback on the document may be addressed to
     feedback-statement? 
}

copyright-statement =
  element copyright-statement { Content-Section }

license-statement =
  element license-statement { Content-Section }

legal-statement =
  element legal-statement { Content-Section }

feedback-statement =
  element feedback-statement { Content-Section }

## One or more definition lists, used to define symbols and abbreviations used in the remainder of the document.
## These can also be used as glossaries, with simple definitions, in contrast to the more elaborate definitions given in
## terms sections 
definitions =
  element definitions {
    OptionalId,
    LocalizedStringAttributes,
    ## Semantic class of clause
    attribute type { text }?,
    attribute obligation { ObligationType }?,
    ## Title of section
    section-title?,
    (
      ## Prefatory material, may be specific to each definition list
      BasicBlock*,
      ## Definition list containing symbols and abbreviations
      dl
    )+
}

content =
  element clause { Content-Section }

## Abstract of a document, presented as a clause
abstract =
  element abstract { Content-Section }

## Acknowledgements of a document, presented as a clause
acknowledgements =
  element acknowledgements { Content-Section }

content-subsection =
  element clause { Content-Section }

## Unnumbered clause with no semantic specialisation, used in preface of document
Content-Section =
    Section-Attributes,
    ## Semantic class of clause
    attribute type { text }?,
    ## Title of section
    section-title?,
    ( (BasicBlock*),
      content-subsection* )

clause =
  element clause { Clause-Section }

## Strictly hierarchical clause: all textual content belongs in a strict clause hierarchy. such that no blocks of text
## are siblings to subclauses (hanging paragraphs)
Clause-Section =
    Section-Attributes,
    ## Semantic class of the clause, e.g. "scope"
    attribute type { text }?,
    ## Title of section
    section-title?,
    (
      ( 
        ## Block content, mutually exclusive  with subclauses
        BasicBlock+ | 
        ## Specification of machine-readable change outlined in this section,
        ## used in document amendments
        amend
      ) |
        ## Subclauses, can include terms and definitions
      (clause-subsection | terms | definitions | floating-title )+
    )

## Clause constituting an annex or appendix
Annex-Section =
    Annex-Section-Attributes,
    Annex-Section-Body

Annex-Section-Attributes =
    Basic-Section-Attributes,
    ## Render the section number and title (if present) inline with the first paragraph of the section
    attribute inline-header { xsd:boolean }?,
    ## Semantic class of clause
    attribute type { text }?

Annex-Section-Body =
    ## Title of clause
    section-title?,
    (
      ## Hanging paragraphs: Annexes permit top-level blocks that are not part of a subsection
      ( BasicBlock* ),
      ## Subclauses of the annex: these can include terms, definitions, and references
       (annex-subsection | terms | definitions | references | floating-title )*
    )

clause-subsection =
  element clause { Clause-Section }

annex-subsection =
  element clause { Annex-Section }

annex =
  element annex {
        Annex-Section,
        annex-appendix*
  }       

## Appendix, distinct subclause type for annexes (annex to annex, rather than subclause to annex)
annex-appendix =
  element appendix { Clause-Section }

## Terms sections give elaborated definitions of terms used in a standardization document
terms =
  element terms {
    Section-Attributes,
    ## Semantic class of clause
    attribute type { text }?,
    ## Title of clause
    section-title?,
    ## Prefatory material
    BasicBlock*,
    ( (term | terms)+ | ( terms*, definitions?) )
  }

## Terminology entry with its definition
term =
  element term {
    TermAttributes,
    ## One or more names under which the term being defined is canonically known
    preferred+,
    ## Zero or more names which are acceptable synonyms for the term being defined
    admitted*,
    ## Zero or more names which are deprecated synonyms for the term being defined
    deprecates*,
    ## Zero or more names which are related to the term being defined. 
    related*,
    ## An optional semantic domain for the term being defined,
    ##  in case the term is ambiguous between several semantic domains
    termdomain?,
    ## Subject of the term
    termsubject?, 
    ## The definition of the term applied in the current document
    termdefinition+,
    ## Zero or more notes about the term
    termnote*,
    ## Zero or more examples of how the term is to be used
    termexample*,
    ## Bibliographic references for the managed term
    TermSource
  }

TermAttributes =
    OptionalId,
    LocalizedStringAttributes,
    BlockAttributes

preferred =
  element preferred { Designation }

admitted =
  element admitted { Designation }

## Term related to the current term
related = 
  element related {
    ## Type of relation of term applicable
    attribute type { RelatedTermType },
    ## Preferred designation of the term related to the current term
    element preferred { Designation },
    ( 
      ## Link to a definition of the term in a bibliographic entry
      eref | 
      ## Stack of links to a definition of the term in a bibliographic entry
      erefstack |
      ## Link to a definition of the term in an element of the current document
      xref |
      ## Link to a definition of the term in a termbase
      termref
    )
}

## The relation of a term to the current term
RelatedTermType = 
  ## The current term deprecates the related term
  "deprecates" |
  ## The current term supersedes the related term
  "supersedes" |
  ## The current term is narrower in denotation than the related term
  "narrower" |
  ## The current term is broader in denotation than the related term
  "broader" |
  ## The current term is equivalent in denotation to the related term
  "equivalent" |
  ## The current term may be compared to the related term
  "compare" |
  ## The current term is understood in contrast to the related term
  "contrast" |
  ## For a better understanding of the current term, one should see the related term
  "see" |
  ## For a better understanding of the current term, one should also see the related term
  "seealso"

deprecates =
  element deprecates { Designation }

## A name under which a managed term is known
Designation = 
  ## Indication that the term designation is missing
  attribute absent { xsd:boolean }?,
  ## The geographic area in which the managed term is known under this designation
  attribute geographic-area { text }?,
  (
    ## Realisation of a designation as a linguistic form
    expression_designation | 
    ## Realisation of a designation as a letter or symbol
    letter_symbol_designation | 
    ## Realisation of a designation as a graphical rendering
    graphical_symbol_designation
  ),
  ## Information about what field/domain the designation is specifically applied to
  fieldofapplication?,
  ## Information about how the designation is to be used
  usageinfo?,
  ## Bibliographic references for this designation of the managed term
  TermSource

fieldofapplication =
  element field-of-application { PureTextElement+ }

usageinfo =
  element usage-info { PureTextElement+ }

## Designation realised as a letter, symbol, formula, equation
letter_symbol_designation =
  element letter-symbol {
    ## Whether the designation is the same across languages, or language-specific   
    attribute isInternational { xsd:boolean }?,
    ## Type of symbolic designation
    attribute type { LetterSymbolType }?,
    ## The symbolic form of the designation
    element name { (PureTextElement | stem)+ }
  }

## The type of a symbol-like designation
LetterSymbolType = 
  ## A letter, possibly subscripted or superscripted, intended to denote some property that it abbreviates
  "letter" |
  ## A non-letter, intended to represent some property
  "symbol" |
  ## A mathematical formula
  "formula" |
  ## A mathematical equation (or inequation)
  "equation"

## Designation realised as a graphical symbol
graphical_symbol_designation =
  element graphical-symbol {
    ## Whether the designation is the same across languages, or language-specific
    attribute isInternational { xsd:boolean }?,
    ## The graphical form of the designation
    figure
  }

## A designation realised as a linguistic form
expression_designation =
  element expression {
    LocalizedStringAttributes,
    ## The type of linguistic form used as designation
    attribute type { ExpressionDesignationType }?,
    ## Whether the designation (typically an abbreviation) is the same across languages, or language-specific
    attribute isInternational { xsd:boolean }?,
    ## The textual form of the designation
    element name { (PureTextElement|stem|index|index-xref)* },
    ## Type of abbreviation that constitutes the designation, according to how it is formed
    element abbreviation-type { AbbreviationType }?,
    ## A pronunciation guide to the designation
    element pronunciation { LocalizedString }?,
    ## Grammatical information about the designation
    element grammar { Grammar }?
  }

## Type of linguistic form used as designation
ExpressionDesignationType =
  ## The form is a prefix
  "prefix" |
  ## The form is a suffix
  "suffix" |
  ## The form is an abbreviation
  "abbreviation" |
  ## The form is a self-standing linguistic expression
  "full"

## Type of abbreviation, according to how it is formed
AbbreviationType =
  ## Abbrevation formed by truncating constituent words
  "truncation" |
  ## Abbrevation formed from the initials of its constituent words, and pronounced as a new word
  "acronym" |
  ## Abbrevation formed from the initials of its constituent words, and pronounced as a sequence of letters
  "initialism"

## Grammatical information about a designation
Grammar =
  ## The grammatical gender of the designation
  element gender { GrammarGender }*,
  ## The grammatical number of the designation
  element number { GrammarNumber }*,
  ## The designation is a preposition
  element isPreposition { xsd:boolean }?,
  ## The designation is a participle
  element isParticiple { xsd:boolean }?,
  ## The designation is an adjective
  element isAdjective { xsd:boolean }?,
  ## The designation is a verb
  element isVerb { xsd:boolean }?,
  ## The designation is an adverb
  element isAdverb { xsd:boolean }?,
  ## The designation is a noun
  element isNoun { xsd:boolean }?,
  ## Miscellaneous grammatical information
  element grammar-value { text }*

## The grammatical gender of the designation
GrammarGender =
  ## Masculine gender
  "masculine" |
  ## Feminine gender
  "feminine" |
  ## Neuter gender
  "neuter" |
  ## Masculine + Feminine gender
  "common"

## The grammatical number of the designation
GrammarNumber =
  ## Singular number
  "singular" |
  ## Dual number
  "dual" |
  ## Plural number
  "plural"
  
termdomain =
  element domain { TextElement+ }

termsubject =
  element subject { TextElement+ }

## The definition of a term applied in the current document
termdefinition =
  element definition {
    ## Type of definition, used to differentiate it from other definitions of the same term if present
    attribute type { text }?,
    (
      ## The content of the definition of the term applied in the current document
      verbaldefinition |
      ## Non-verbal representation of the term applied in the current document
      nonverbalrep |
      (verbaldefinition, nonverbalrep)
    )
  }

verbaldefinition = element verbal-definition {
    ## Content of the verbal representation of the term
    (paragraph-with-footnote | dl | ol | ul | table | figure | formula)+,
    ## Bibliographic references for this designation of the managed term
    TermSource
}

## Non-verbal representation of the term
nonverbalrep =
  element non-verbal-representation {
    ## Content of the non-verbal representation of the term
    ( table | figure | formula )+,
    ## Bibliographic references for this designation of the managed term
    TermSource
}

termnote =
  element termnote { 
    RequiredId,
    NumberingAttributes,
    BlockAttributes,
    ## Content of the term note
    (paragraph-with-footnote | ul | ol | dl | formula)+
}

termexample =
  element termexample { 
    RequiredId,
    BlockAttributes,
    ## Content of the term example
    ( formula | ul | ol | dl | quote | sourcecode | paragraph-with-footnote | figure )+
}

## The bibliographic source where a term is defined in the sense applicable in this standardisation document
termsource =
  element source {
    ## The status of the term as it is used in this document, relative to its definition in the original document
    attribute status { SourceStatusType },
    ## The type of the managed term in the present context
    attribute type { SourceTypeType },
    ## The original document and location where the term definition has been obtained from
    origin,
    ## Any changes that the definition of the term has undergone relative to the original document,
    ## in order to be applicable in this standardisation document
    modification?
}

## The status of a term as it is used in this document, relative to its definition in the original document
SourceStatusType =
   ## The managed term in the present context is identical to the term as found in the bibliographic source
   "identical" |
   ## The managed term in the present context has been modified from the term as found in the bibliographic source
   "modified" |
   ## The managed term in the present context has been modified from the term as found in the bibliographic source, in order
   ## to better fit some local requirement, though still with the intent of retaining the original meaning as much as possible
   "adapted" |
   ## The managed term in the present context has been restyled from the term as found in the bibliographic source
   "restyled" |
   ## The managed term in the present context has had context added to it, relative to the term as found in the bibliographic source
   "context-added" |
   ## The managed term in the present context is a generalisation of the term as found in the bibliographic source
   "generalisation" |
   ## The managed term in the present context is a specialisation of the term as found in the bibliographic source
   "specialisation" |
   ## The managed term in the present context is in an unspecified relation to the term as found in the bibliographic source
   "unspecified"

## The type of the managed term in the present context
SourceTypeType =
  ## The managed term is authoritative in the present context
  "authoritative" |
  ## The managed term constitutes lineage in the present context
  "lineage"

origin =
  element origin { erefType | termref }

modification =
  element modification { paragraph }

## Cross-reference to a term defined within a termbase
termref = element termref {
  ## Identifier of the termbase
  attribute base { text },
  ## Identifier of the term within the termbase
  attribute target { text },
  ## Text to display for the cross-reference to the term
  PureTextElement*
}

term-clause =
  element clause {
    Basic-Section-Attributes,
    ## Render the section number and title (if present) inline with the first paragraph of the section
    attribute inline-header { xsd:boolean }?,
    section-title?,
    ## Prefatory text
    BasicBlock*,
    (
       (term-clause | terms | definitions)*
    )
}

termdocsource =
  element termdocsource { CitationType }

## Specification of how blocks of a given class should be autonumbered within an AmendBlock newContent element
autonumber =
  element autonumber {
    ## The class of block to apply autonumbering to, within an AmendBlock newContent element
    attribute type { "requirement" | "recommendation" | "permission" | "table" | "figure" | "admonition" | "formula" | "sourcecode" | "example" | "note" },
    ## The starting value of numbering for the blocks with that class
    text
}

## Wrapper around an image file, to specify an image map, with areas of an image being hyperlinked
imagemap = element imagemap {
  BlockAttributes,
  ## the image to be hyperlinked
  figure, 
  ## Specification of an area of an image to be hyperlinked, as part of an image map
  imagemaparea*
} 

## Specification of an area of an image to be hyperlinked, as part of an image map
imagemaparea =
  element area {
    ## Type of an image map area of an image that is hyperlinked
    attribute type { "rect" | "circle" | "ellipse" | "poly" },
    ## Element that this image map area links to
    ( xref | hyperlink | eref | erefstack ),
    ## Polygon defined shape of the image map area
    element coords {
      ## X-coordinate of a coordinate point
      attribute x { xsd:float },
      ## Y-coordinate of a coordinate point
      attribute y { xsd:float }
    }+,
    ## Radius-defined shape of the image map area
    element radius {
      ## X-coordinate of the center of a circle area within the image map
      attribute x { xsd:float },
      ## Y-coordinate of the center of a circle area within the image map
      attribute y { xsd:float }?
    }?
  }

## Wrapper around an SVG file, to update its hyperlinks with potentially document-specific
## links, so that the SVG file can hyperlink to anchors within the document
svgmap = element svgmap {
  BlockAttributes,
  ## The SVG file to be updated
  figure,
  ## Specification of the cross-references to update the SVG file with
  svg_target*
}

## Specification of (potentially document-specific) cross-references, to overwrite the
## links within an SVG file, so that the SVG file can hyperlink to anchors within the document
svg_target =
  element target {
    ## The value of the `href` attribute in the SVG file to be overwritten
    attribute href { xsd:anyURI },
    ## The cross-reference or hyperlink, whose value is to overwrite the value of the `href` attribute in the SVG file
    ( xref | hyperlink | eref | erefstack )
}

## Unordered list item for standards documents
ul_li =
  element li {
    OptionalId, 
    UlLiAttributes, 
    UlLiBody
}  

UlLiBody =
    BasicBlock+

UlLiAttributes =
    ## Include a checkbox for the list item
    attribute uncheckedcheckbox { xsd:boolean }?,
    ## Check the checkbox for the list item
    attribute checkedcheckbox { xsd:boolean }?


## A floating title, outside of the clause hierarchy of the document
floating-title =
  element floating-title {
    RequiredId,
    ## The ostensive depth of the floating title in the clause hierarchy: which level heading it should be presented as
    attribute depth { xsd:int },
    ## Textual content of the floating title
    TextElement*
}

## Connective linking the current cross-reference target to its predecessor
XrefConnectiveType = "and" | "or" | "from" | "to" | ""

## Description of location in a reference, which can be combined with other locations in a single citation
XrefTarget =
  element location {
    ## Anchor within the document to point to
    attribute target { xsd:string { pattern = "\i\c*|\c+#\c+" }},
    ## Connective linking this location to its predecessor. _from/to_ are presumed to nest more closely than _and_ or _or_
    attribute connective { XrefConnectiveType }
}

## Style of how a cross-reference is to be rendered
XrefStyleType =
  ## Render cross-reference only through the title of the element (e.g. "The hunting of the snark"
  "basic" |
  ## Render cross-reference as a combination of title and the numbering and type of the element (e.g. Chapter 3, "The hunting of the snark")
  "full" |
  ## Default style: render cross-reference only through the numbering and type of the element (e.g. Chapter 3)
  "short" |
  ## Render cross-reference as the anchor or identifier used to identify the target
  "id" |
  ## Extension point: User-defined rendering style (e.g. "modspec" for cross-references compliant to the OGC Modspec model of cross-referencing requirements from other requirements, independent of how those requirements are cross-referenced within a standards document.)
  text

## Cross-reference to an bibliographic reference within a standardisatin document, with a connective
erefTypeWithConnective =
    ## Connective linking this location to its predecessor. _from/to_ are presumed to nest more closely than _and_ or _or_
    attribute connective { XrefConnectiveType }?,
    erefType

## Set of cross-references to bibliographic references within a standardisation document, joined with connectives
erefstack = element erefstack {
    ## Cross-reference to a bibliographic reference
    element eref { erefTypeWithConnective }+
}

BlockAttributes =
    ## Keep this block on the same page as the following block in paged media
    attribute keep-with-next { xsd:boolean }?,
    ## Do not permit a page break between the lines of the block in paged media
    attribute keep-lines-together { xsd:boolean }?,
    ## Non-unique identifier within document. Used to align two blocks in different languages in a multilingual document
    attribute tag { text }?,
    ## Specification of how a block element may be rendered in a multilingual document
    attribute multilingual-rendering { MultilingualRenderingType }?,
    ## Set the columns display of the current block, overriding the display inherited from the document.
    ## For example, if the document is set to two-column, this attribute would be used to set the block
    ## to span across both columns
    attribute columns { text }?

ReferencesAttributes =
    attribute obligation { ObligationType }?,
    ## Whether this is a normative references section or informative (bibliography). Not the same as obligation:
    ## Normative References contents contain normative references, but as a clause in the document, they are informative.
    attribute normative { xsd:boolean }

TermSource =
    termsource*

BlockSource = source*

start = standard-document
}
