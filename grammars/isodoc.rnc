# instantiations of this grammar may replace leaf strings
# with more elaborated types; e.g. title (text) replaced with
# title-main, title-intro, title-part; type replaced with
# enum.
#
# some renaming at leaf nodes is permissible
#
# obligations can change both from optional to mandatory,
# and from mandatory to optional; optional elements may
# be omitted; freely positioned alternatives may be replaced
# with strict ordering
#
# DO NOT introduce a namespace here. We do not want a distinct namespace
# for these elements, and a distinct namespace for any grammar inheriting
# these elements; we just want one namespace for any child grammars
# of this.

grammar {

include "reqt.rnc" { }

include "basicdoc.rnc" { 

amend = element amend {
  BlockAttributes,
  AmendType,
  autonumber*
}

AdmonitionAttr =
    attribute type { AdmonitionType },
    attribute class { text }?,
    attribute uri { xsd:anyURI }?,
    attribute coverpage { xsd:boolean }?,
    attribute notag { xsd:boolean }?

AdmonitionType = 
  "warning" | "note" | "tip" | "important" | "caution" | "statement" | "editorial" | "box"

index = element index {
  attribute to { xsd:IDREF }?,
  element primary { (PureTextElement|stem)+ },
  element secondary { (PureTextElement|stem)+ }?,
  element tertiary { (PureTextElement|stem)+ }?
}

## Title(s) of a clause
section-title =
  ## Title proper for a clause
  element title { TextElement* },
  ## Alternate title for a clause
  element variant-title { TypedTitleString }*

hyperlink =
  element link {
    attribute target { xsd:anyURI },
    attribute type { ReferenceFormat }?,
    attribute alt { text }?,
    attribute update-type { xsd:boolean }?,
    attribute style { text }?,
    PureTextElement+
}

xref =
  element xref {
     XrefAttributes,
     XrefBody
}

erefType =
    attribute normative { xsd:boolean }?,
    attribute citeas { text },
    attribute type { ReferenceFormat }?,
    attribute alt { text }?,
    attribute case { "capital" | "lowercase" }?,
    attribute droploc { xsd:boolean }?,
    attribute style { text }?,
    CitationType,
    PureTextElement+

UlAttr =
    BlockAttributes

UlBody =
    tname?, ul_li+, note*

OlBody =
    tname?, li+, note*

OlAttr =
    BlockAttributes,
    attribute type { ( "roman" | "alphabet" | "arabic" |
                       "roman_upper" | "alphabet_upper" ) }?

DlAttr =
    BlockAttributes,
    attribute key { xsd:boolean }?

DlBody =
    tname?, (dt, dd)+, note*

dt =
  element dt { 
    OptionalId,
    TextElement*
  }

ExampleAttr =
    attribute unnumbered { xsd:boolean }?,
    attribute subsequence { text }?,
    attribute number { text }?,
    BlockAttributes

ExampleBody =
    tname?,
    ( formula | ul | ol | dl | quote | sourcecode | paragraph-with-footnote | figure )+,
    note*

TableAttr =
    attribute unnumbered { xsd:boolean }?,
    attribute number { text }?,
    attribute subsequence { text }?,
    attribute alt { text }?,
    attribute summary { text }?,
    attribute uri { xsd:anyURI }?,
    attribute width { text }?,
    BlockAttributes

TableBody =
    colgroup?, tname?, thead?, tbody, tfoot?, dl?, table-note*, source*

FigureAttr =
    attribute unnumbered { xsd:boolean }?,
    attribute number { text }?,
    attribute subsequence { text }?,
    attribute class { text }?,
    attribute width { text }?,
    BlockAttributes

FigureBody =
     tname?, (image | video | audio | pre | paragraph-with-footnote+ | figure*), fn*, dl?, note*, source*

source =
  element source {
    attribute status { SourceStatusType },
    origin, modification?
} 

SourceAttr =
    attribute unnumbered { xsd:boolean }?,
    attribute number { text }?,
    attribute subsequence { text }?,
    attribute lang { LanguageType }?,
    BlockAttributes,
    attribute linenums { xsd:boolean }?

SourceBody =
    tname?, ( text | callout | xref | eref )+, annotation*, note*

FormulaAttr =
    attribute unnumbered { xsd:boolean }?,
    attribute number { text }?,
    attribute subsequence { text }?,
    attribute inequality { xsd:boolean }?,
    BlockAttributes

ParagraphAttrs =
    attribute align { Alignments }?,
    attribute type { text }?,
    BlockAttributes

QuoteAttr =
    attribute alignment { Alignments }?,
    BlockAttributes

# TitleType = text

sections =
  element sections {
    ( clause | terms | term-clause | definitions | floating-title )+
}

## Bibliography clause. It is used to collate references within the document, where
## there could be one or more of such sections within a document. For example, some standardization documents differentiate
## normative or informative references, some split references into sections organized by concept relevance.
references =
  element references {
    attribute id { xsd:ID }?,
    attribute obligation { ObligationType }?,
    ## Whether this is a normative references section or informative (bibliography). Not the same as obligation:
    ## Normative References contents contain normative references, but as a clause in the document, they are informative.
    attribute normative { xsd:boolean },
    section-title?,
    ## Prefatory text
    BasicBlock*,
    (
      ## Bibliographic item cited in the document
      doc_bibitem,
      ## Annotation of the bibliographic item
      note*)*,
    references*
}

NoteAttr =
    attribute unnumbered { xsd:boolean }?,
    attribute number { text }?,
    attribute subsequence { text }?,
    attribute type { text }?,
    attribute coverpage { xsd:boolean }?,
    attribute notag { xsd:boolean }?,
    BlockAttributes

NoteBody =
    (paragraph | ul | ol | dl | formula | quote | sourcecode)+

Basic-Section =
    Basic-Section-Attributes,
    section-title?,
    (BasicBlock+)

LiBody =
    BasicBlock+
    # exclude figures?

dd =
  element dd {
    # exclude figures?
    BasicBlock*
  }

thead = element thead { tr+ }

TdBody =
    (
      (TextElement | fn )* |
      (paragraph-with-footnote | dl | ul | ol | figure)+
    )

ThBody =
    (
      (TextElement | fn )* |
      paragraph-with-footnote+
    )

table-note = element note {
    attribute id { xsd:ID }?,
    paragraph
}

stem =
  element stem {
    attribute type { "MathML" | "AsciiMath" | "LatexMath" },
    attribute number-format { text }?,
    attribute block { xsd:boolean },
     ( text | AnyElement )+
} 

em = element em { (PureTextElement|stem|index|index-xref|eref|erefstack|xref|hyperlink)* }
strong = element strong { (PureTextElement|stem|index|index-xref|eref|erefstack|xref|hyperlink)* }
tt = element tt { (PureTextElement|index|index-xref|eref|erefstack|xref|hyperlink)* }
keyword = element keyword { (PureTextElement|index|index-xref)* }
strike = element strike { (PureTextElement|index|index-xref)* }
underline = element underline { (PureTextElement|index|index-xref)* }
smallcap = element smallcap { (PureTextElement|index|index-xref)* }
sub = element sub { (PureTextElement|stem)* }
sup = element sup { (PureTextElement|stem)* }

pagebreak = element pagebreak { 
  attribute orientation { "landscape" | "portrait" }?
}

}

# end overrides

## Two-letter language code taken from ISO-639, indicating the language in which the content is written
LanguageType = text

## Four-letter script code taken from ISO-15924, indicating the script in which the content is written
ScriptType = text

## The force of a clause in a standard document: whether it has normative or informative effect
ObligationType = "normative" | "informative"

doc_bibitem =
  element bibitem {
     attribute id { xsd:ID },
     attribute hidden { xsd:boolean }?,
     attribute suppress_identifier { xsd:boolean }?,
     ReducedBibliographicItem
}


image |=
  element svg {
     ( text | AnyElement )+
}

BasicBlock |= columnbreak

columnbreak = element columnbreak { empty }

MultilingualRenderingType = "common" | "all-columns" | "parallel" | "tag"

colgroup = element colgroup { col+ }

col = element col {
    attribute width { text }
}

BibItemType |= "internal"

TextElement |= concept | add | del | span | erefstack | date_inline
PureTextElement |= passthrough_inline

passthrough_inline = element passthrough {
        attribute formats { text }?,
        text
}

add = element add { PureTextElement | eref | erefstack | stem | keyword | xref | hyperlink | index | index-xref }
del = element del { PureTextElement | eref | erefstack | stem | keyword | xref | hyperlink | index | index-xref }
span = element span {
  attribute class { text }?,
  attribute style { text }?,
  attribute custom-charset { text }?,
  TextElement+
}

date_inline = element date {
  attribute value { text },
  attribute format { text }?,
  attribute language { LanguageType }?,
  attribute script { ScriptType }?,
  attribute locale { text }?
}

## Formally defined concept used in a standardisation document, aligned to a definition.
## That concept may be defined as a term within the current document, or it may be defined externally
concept = element concept {
  ## Render the term in the concept in boldface
  attribute bold { xsd:boolean }?,
  ## Render the term in the concept in italics
  attribute ital { xsd:boolean }?,
  ## Render a reference to a definition for the concept, e.g. "widgets (3.1)"
  attribute ref { xsd:boolean }?,
  ## Hyperlink the mention of the term to the definition for the concept
  attribute linkmention { xsd:boolean }?,
  ## Hyperlink the reference for the term to the definition for the concept
  attribute linkref { xsd:boolean }?,
  ## The canonical name of the concept being defined
  element refterm { (PureTextElement|stem|index|index-xref)* }?,
  ## The rendering to be used for the concept
  element renderterm { (PureTextElement|stem|index|index-xref)* }?,
  ( 
     ## Link to a definition of the term in a bibliographic entry
     eref | 
     ## Stack of links to a definition of the term in a bibliographic entry
     erefstack | 
     ## Link to a definition of the term in an element of the current document
     xref | 
     ## Link to a definition of the term in a termbase
     termref 
  )
}

BasicBlock |= requirement | recommendation | permission | imagemap | svgmap | inputform | toc | passthrough

toc = element toc {
   ( ul )
}

passthrough = element passthrough {
    attribute formats { text }?,
    text
}

inputform = element form {
    attribute id { xsd:ID },
    attribute name { text },
    attribute action { text },
    attribute class { text }?,
    BlockAttributes,
    ( TextElement | FormInput )*
}

FormInput = input | formlabel | select | textarea

InputType = "button" | "checkbox" | "date" | "file" | "password" | "radio" | "submit" | "text"

input = element input {
    attribute type { InputType },
    attribute checked { xsd:boolean }?,
    attribute disabled { xsd:boolean }?,
    attribute readonly { xsd:boolean }?,
    attribute maxlength { xsd:int }?,
    attribute minlength { xsd:int }?,
    attribute name { text }?,
    attribute value { text }?,
    attribute id { xsd:ID }?
}

formlabel = element label {
    attribute for { xsd:IDREF },
    PureTextElement*
}

select = element select {
    attribute name { text }?,
    attribute value { text }?,
    attribute id { xsd:ID }?,
    attribute disabled { xsd:boolean }?,
    attribute multiple { xsd:boolean }?,
    attribute size { xsd:int }?,
    option+
}

option = element option {
    attribute disabled { xsd:boolean }?,
    attribute value { text }?,
    PureTextElement*
}

textarea = element textarea {
    attribute name { text }?,
    attribute value { text }?,
    attribute id { xsd:ID }?,
    attribute rows { xsd:int }?,
    attribute cols { xsd:int }?
}

bibliography =
  element bibliography {
    (references | reference-clause)+
}

Section-Attributes =
    Basic-Section-Attributes,
    attribute inline-header { xsd:boolean }?,
    ## Value of number to be used for numbering of section, overriding any autonumbering in rendering.
    ## The section number is still formed by appending this number to the hierarchical set of parent section numbers,
    ## e.g. a number "3a" under Clause 1 subclause 2 will be numbered as 1.2.3a.
    attribute number { text }?,
    ## Value of number to be used for numbering of section, overriding any autonumbering in rendering,
    ## and the hierarchy of parent section numbers. This attribute is mutually exclusive with `number`.
    ## So under Clause 1 subclause 2, sub-subclause 3 is numbered as 1.2.3. If the following sub-subclause
    ## is given a branch-number "7.2.1.5", that will be the overall section number given, ignoring the parent section
    ## numbers.
    attribute branch-number { text }?,
    ## Do not apply numbering to this clause
    attribute unnumbered { xsd:boolean }?

Basic-Section-Attributes =
    attribute id { xsd:ID }?,
    attribute language { LanguageType }?,
    attribute script { ScriptType }?,
    attribute obligation { ObligationType }?

reference-clause =
  element clause {
    Section-Attributes,
    section-title?,
    BasicBlock*,
    (
       reference-clause+ | references*
    )
}

Root-Attributes =
  ## Version number of the gem used to generate this document
  attribute version { text },
  ## Version number of the schema that this document is aligned to
  attribute schema-version { text },
  ## Type of standards document representation. "Semantic" is the core representation of content.
  ## "Presentation" manipulates and enhances the representation for rendering needs.
  attribute type { "semantic" | "presentation" }

## Representation of a standardisation document
standard-document =
element standard-document {
  Root-Attributes,
  ## Bibliographic description of the document itself, expressed in the Relaton model
  bibdata, 
  ## Extension point for extraneous elements that need to be added to standards document as data
  misccontainer?, 
  ## Front matter that is repeated at the start of documents issued from an SDO, with content not specific to the document
  boilerplate?, 
  ## Prefatory sections
  preface?, 
  ## Main body of document
  sections, 
  ## Annex sections
  annex*, 
  ## Bibliographic sections
  bibliography?, 
  ## Index of the document
  indexsect*, 
  ## Colophon or postface material
  colophon?
}

## Elements added to metanorma-extension are open-ended, and constitute source data
misccontainer = element metanorma-extension { AnyElement+ }

preface =
  element preface { ( content | abstract | foreword | introduction | acknowledgements)+ }

colophon =
  element colophon { content+ }

## Foreword of document
foreword =
  element foreword { Content-Section }

## Introduction of document
introduction =
  element introduction { Content-Section }

indexsect = element indexsect { Content-Section }

## Content addressing legal and licensing concerns around the document, outside of the main flow of document content
boilerplate = 
  element boilerplate { 
     ## Preset templated text provided by the standardization body, describing the copyright status of the document
     copyright-statement?, 
     ## Preset templated text provided by the standardization body, providing the licensing terms for the document content
     license-statement?, 
     ## Preset templated text provided by the standardization body, providing the legal constraints and considerations around use of the document
     legal-statement?, 
     ## Preset templated text provided by the standardization body, providing information on where feedback on the document may be addressed to
     feedback-statement? 
}

copyright-statement =
  element copyright-statement { Content-Section }

license-statement =
  element license-statement { Content-Section }

legal-statement =
  element legal-statement { Content-Section }

feedback-statement =
  element feedback-statement { Content-Section }

## One or more definition lists, used to define symbols and abbreviations used in the remainder of the document.
## These can also be used as glossaries, with simple definitions, in contrast to the more elaborate definitions given in
## terms sections 
definitions =
  element definitions {
    attribute id { xsd:ID }?,
    attribute language { LanguageType }?,
    attribute script { ScriptType }?,
    attribute type { text }?,
    attribute obligation { ObligationType }?,
    section-title?,
    (
      ## Prefatory material, may be specific to each definition list
      BasicBlock*,
      ## Definition list containing symbols and abbreviations
      dl
    )+
}

content =
  element clause { Content-Section }

## Abstract of a document, presented as a clause
abstract =
  element abstract { Content-Section }

## Acknowledgements of a document, presented as a clause
acknowledgements =
  element acknowledgements { Content-Section }

content-subsection =
  element clause { Content-Section }

## Unnumbered clause with no semantic specialisation, used in preface of document
Content-Section =
    Section-Attributes,
    attribute type { text }?,
    section-title?,
    ( (BasicBlock*),
      content-subsection* )

clause =
  element clause { Clause-Section }

## Strictly hierarchical clause: all textual content belongs in a strict clause hierarchy. such that no blocks of text
## are siblings to subclauses (hanging paragraphs)
Clause-Section =
    Section-Attributes,
    ## Semantic class of the clause, e.g. "scope"
    attribute type { text }?,
    section-title?,
    (
      ( 
        ## Block content, mutually exclusive  with subclauses
        (  BasicBlock+ ) | 
        ## Specification of machine-readable change outlined in this section,
        ## used in document amendments
        amend ) |
        ## Subclauses, can include terms and definitions
       (clause-subsection | terms | definitions | floating-title )+
    )

## Clause constituting an annex or appendix
Annex-Section =
    Annex-Section-Attr,
    Annex-Section-Body

Annex-Section-Attr =
    Basic-Section-Attributes,
    attribute inline-header { xsd:boolean }?,
    attribute type { text }?

Annex-Section-Body =
    section-title?,
    (
      ## Hanging paragraphs: Annexes permit top-level blocks that are not part of a subsection
      ( BasicBlock* ),
      ## Subclauses of the annex: these can include terms, definitions, and references
       (annex-subsection | terms | definitions | references | floating-title )*
    )

clause-subsection =
  element clause { Clause-Section }

annex-subsection =
  element clause { Annex-Section }

annex =
  element annex { Annex-Section }       

## Terms sections give elaborated definitions of terms used in a standardization document
terms =
  element terms {
    Section-Attributes,
    attribute type { text }?,
    section-title?,
    ## Prefatory material
    BasicBlock*,
    ( (term | terms)+ | ( terms*, definitions?) )
  }

## Terminology entry with its definition
term =
  element term {
    attribute id { xsd:ID }?,
    ## Langauge in which the term entry is written
    attribute language { LanguageType }?,
    ## Script in which the term entry is written
    attribute script { ScriptType }?,
    BlockAttributes,
    ## One or more names under which the term being defined is canonically known
    preferred+,
    ## Zero or more names which are acceptable synonyms for the term being defined
    admitted*,
    ## Zero or more names which are deprecated synonyms for the term being defined
    deprecates*,
    ## Zero or more names which are related to the term being defined. 
    related*,
    ## An optional semantic domain for the term being defined,
    ##  in case the term is ambiguous between several semantic domains
    termdomain?,
    ## Subject of the term
    termsubject?, 
    ## The definition of the term applied in the current document
    termdefinition+,
    ## Zero or more notes about the term
    termnote*,
    ## Zero or more examples of how the term is to be used
    termexample*,
    ## Bibliographic references for the managed term
    termsource*
  }

preferred =
  element preferred { Designation }

admitted =
  element admitted { Designation }

## Term related to the current term
related = 
  element related {
    ## Type of relation of term applicable
    attribute type { RelatedTermType },
    ## Preferred designation of the term related to the current term
    element preferred { Designation },
    ( 
      ## Link to a definition of the term in a bibliographic entry
      eref | 
      ## Stack of links to a definition of the term in a bibliographic entry
      erefstack |
      ## Link to a definition of the term in an element of the current document
      xref |
      ## Link to a definition of the term in a termbase
      termref
    )
}

## The relation of a term to the current term
RelatedTermType = 
  ## The current term deprecates the related term
  "deprecates" |
  ## The current term supersedes the related term
  "supersedes" |
  ## The current term is narrower in denotation than the related term
  "narrower" |
  ## The current term is broader in denotation than the related term
  "broader" |
  ## The current term is equivalent in denotation to the related term
  "equivalent" |
  ## The current term may be compared to the related term
  "compare" |
  ## The current term is understood in contrast to the related term
  "contrast" |
  ## For a better understanding of the current term, one should see the related term
  "see" |
  ## For a better understanding of the current term, one should also see the related term
  "seealso"

deprecates =
  element deprecates { Designation }

## A name under which a managed term is known
Designation = 
  ## Indication that the term designation is missing
  attribute absent { xsd:boolean }?,
  ## The geographic area in which the managed term is known under this designation
  attribute geographic-area { text }?,
  (
    ## Realisation of a designation as a linguistic form
    expression_designation | 
    letter_symbol_designation | 
    graphical_symbol_designation
  ),
  ## Information about what field/domain the designation is specifically applied to
  fieldofapplication?,
  ## Information about how the designation is to be used
  usageinfo?,
  ## Bibliographic references for this designation of the managed term
  termsource*

fieldofapplication =
  element field-of-application { PureTextElement+ }

usageinfo =
  element usage-info { PureTextElement+ }

## Designation realised as a letter, symbol, formula, equation
letter_symbol_designation =
  element letter-symbol {
    ## Whether the designation is the same across languages, or language-specific   
    attribute isInternational { xsd:boolean }?,
    ## Type of symbolic designation
    attribute type { LetterSymbolType }?,
    ## The symbolic form of the designation
    element name { (PureTextElement | stem)+ }
  }

## The type of a symbol-like designation
LetterSymbolType = 
  ## A letter, possibly subscripted or superscripted, intended to denote some property that it abbreviates
  "letter" |
  ## A non-letter, intended to represent some property
  "symbol" |
  ## A mathematical formula
  "formula" |
  ## A mathematical equation (or inequation)
  "equation"

## Designation realised as a graphical symbol
graphical_symbol_designation =
  element graphical-symbol {
    ## Whether the designation is the same across languages, or language-specific
    attribute isInternational { xsd:boolean }?,
    ## The graphical form of the designation
    figure
  }

## A designation realised as a linguistic form
expression_designation =
  element expression {
    ## The language in which the designation is written
    attribute language { LanguageType }?,
    ## The script in which the designation is written
    attribute script { ScriptType }?,
    ## The type of linguistic form used as designation
    attribute type { ExpressionDesignationType }?,
    ## Whether the designation (typically an abbreviation) is the same across languages, or language-specific
    attribute isInternational { xsd:boolean }?,
    ## The textual form of the designation
    element name { (PureTextElement|stem|index)* },
    ## Type of abbreviation that constitutes the designation, according to how it is formed
    element abbreviation-type { AbbreviationType }?,
    ## A pronunciation guide to the designation
    element pronunciation { LocalizedString }?,
    ## Grammatical information about the designation
    element grammar { Grammar }?
  }

## Type of linguistic form used as designation
ExpressionDesignationType =
  ## The form is a prefix
  "prefix" |
  ## The form is a suffix
  "suffix" |
  ## The form is an abbreviation
  "abbreviation" |
  ## The form is a self-standing linguistic expression
  "full"

## Type of abbreviation, according to how it is formed
AbbreviationType =
  ## Abbrevation formed by truncating constituent words
  "truncation" |
  ## Abbrevation formed from the initials of its constituent words, and pronounced as a new word
  "acronym" |
  ## Abbrevation formed from the initials of its constituent words, and pronounced as a sequence of letters
  "initialism"

## Grammatical information about a designation
Grammar =
  ## The grammatical gender of the designation
  element gender { GrammarGender }*,
  ## The grammatical number of the designation
  element number { GrammarNumber }*,
  ## The designation is a preposition
  element isPreposition { xsd:boolean }?,
  ## The designation is a participle
  element isParticiple { xsd:boolean }?,
  ## The designation is an adjective
  element isAdjective { xsd:boolean }?,
  ## The designation is a verb
  element isVerb { xsd:boolean }?,
  ## The designation is an adverb
  element isAdverb { xsd:boolean }?,
  ## The designation is a noun
  element isNoun { xsd:boolean }?,
  ## Miscellaneous grammatical information
  element grammar-value { text }*

## The grammatical gender of the designation
GrammarGender =
  ## Masculine gender
  "masculine" |
  ## Feminine gender
  "feminine" |
  ## Neuter gender
  "neuter" |
  ## Masculine + Feminine gender
  "common"

## The grammatical number of the designation
GrammarNumber =
  ## Singular number
  "singular" |
  ## Dual number
  "dual" |
  ## Plural number
  "plural"
  
termdomain =
  element domain { TextElement+ }

termsubject =
  element subject { TextElement+ }

## The definition of a term applied in the current document
termdefinition =
  element definition {
    ## Type of definition, used to differentiate it from other definitions of the same term if present
    attribute type { text }?,
    (
      ## The content of the definition of the term applied in the current document
      verbaldefinition |
      ## Non-verbal representation of the term applied in the current document
      nonverbalrep |
      (verbaldefinition, nonverbalrep)
    )
  }

verbaldefinition = element verbal-definition {
    (paragraph | dl | ol | ul | table | figure | formula)+,
    termsource*
}

## Non-verbal representation of the term
nonverbalrep =
  element non-verbal-representation {
    ## Content of the non-verbal representation of the term
    ( table | figure | formula )+,
    ## Bibliographic references for this designation of the managed term
    termsource*
}

termnote =
  element termnote { 
    attribute id { xsd:ID },
    attribute unnumbered { xsd:boolean }?,
    attribute number { text }?,
    attribute subsequence { text }?,
    BlockAttributes,
    (paragraph | ul | ol | dl | formula)+
}

termexample =
  element termexample { 
    attribute id { xsd:ID },
    BlockAttributes,
    ( formula | ul | ol | dl | quote | sourcecode | paragraph | figure )+
}

## The bibliographic source where a term is defined in the sense applicable in this standardisation document
termsource =
  element termsource {
    ## The status of the term as it is used in this document, relative to its definition in the original document
    attribute status { SourceStatusType },
    ## The type of the managed term in the present context
    attribute type { SourceTypeType },
    ## The original document and location where the term definition has been obtained from
    origin,
    ## Any changes that the definition of the term has undergone relative to the original document,
    ## in order to be applicable in this standardisation document
    modification?
}

## The status of a term as it is used in this document, relative to its definition in the original document
SourceStatusType =
   ## The managed term in the present context is identical to the term as found in the bibliographic source
   "identical" |
   ## The managed term in the present context has been modified from the term as found in the bibliographic source
   "modified" |
   ## The managed term in the present context has been modified from the term as found in the bibliographic source, in order
   ## to better fit some local requirement, though still with the intent of retaining the original meaning as much as possible
   "adapted" |
   ## The managed term in the present context has been restyled from the term as found in the bibliographic source
   "restyled" |
   ## The managed term in the present context has had context added to it, relative to the term as found in the bibliographic source
   "context-added" |
   ## The managed term in the present context is a generalisation of the term as found in the bibliographic source
   "generalisation" |
   ## The managed term in the present context is a specialisation of the term as found in the bibliographic source
   "specialisation" |
   ## The managed term in the present context is in an unspecified relation to the term as found in the bibliographic source
   "unspecified"

## The type of the managed term in the present context
SourceTypeType =
  ## The managed term is authoritative in the present context
  "authoritative" |
  ## The managed term constitutes lineage in the present context
  "lineage"

origin =
  element origin { erefType | termref }

modification =
  element modification { paragraph }

termref = element termref {
  attribute base { text },
  attribute target { text },
  text?
}

term-clause =
  element clause {
    Basic-Section-Attributes,
    attribute inline-header { xsd:boolean }?,
    section-title?,
    BasicBlock*,
    (
       (term-clause | terms | definitions)*
    )
}

termdocsource =
  element termdocsource { CitationType }

autonumber =
  element autonumber {
    attribute type { "requirement" | "recommendation" | "permission" | "table" | "figure" | "admonition" | "formula" | "sourcecode" | "example" | "note" },
    text
}

imagemap = element imagemap {
    BlockAttributes,
  figure, 
  element area {
    attribute type { "rect" | "circle" | "ellipse" | "poly" },
    ( xref | hyperlink | eref | erefstack ),
    element coords {
      attribute x { xsd:float },
      attribute y { xsd:float }
    }+,
    element radius {
      attribute x { xsd:float },
      attribute y { xsd:float }?
    }?
  }*
}

svgmap = element svgmap {
    BlockAttributes,
  figure,
  element target {
     attribute href { xsd:anyURI },
    ( xref | hyperlink | eref | erefstack )
  }*
}

ul_li =
  element li {
    attribute id { xsd:ID }?,
    attribute uncheckedcheckbox { xsd:boolean }?,
    attribute checkedcheckbox { xsd:boolean }?,
    BasicBlock+
}

## A floating title, outside of the clause hierarchy of the document
floating-title =
  element floating-title {
    attribute id { xsd:ID },
    ## The ostensive depth of the floating title in the clause hierarchy: which level heading it should be presented as
    attribute depth { xsd:int },
    ## Textual content of the floating title
    TextElement*
}

XrefAttributes =
     attribute target { xsd:string { pattern = "\i\c*|\c+#\c+" }},
     attribute to { xsd:string { pattern = "\i\c*|\c+#\c+" }}?,
     attribute type { ReferenceFormat }?,
     attribute alt { text }?,
     attribute case { "capital" | "lowercase" }?,
     attribute droploc { xsd:boolean }?,
     attribute style { XrefStyleType }?,
     attribute label { text }?

XrefBody =
     XrefTarget*,
     PureTextElement+

XrefConnectiveType = "and" | "or" | "from" | "to" | ""

XrefTarget =
  element location {
    attribute target { xsd:string { pattern = "\i\c*|\c+#\c+" }},
    attribute connective { XrefConnectiveType }
}

XrefStyleType = "basic" | "full" | "short" |"id" | text

erefTypeWithConnective =
    attribute connective { XrefConnectiveType }?,
    erefType

erefstack = element erefstack {
    element eref { erefTypeWithConnective }+
}

BlockAttributes =
    attribute keep-with-next { xsd:boolean }?,
    attribute keep-lines-together { xsd:boolean }?,
    ## Non-unique identifier within document. Used to align two blocks in different languages in a multilingual document
    attribute tag { text }?,
    ## Specification of how a block element may be rendered in a multilingual document
    attribute multilingual-rendering { MultilingualRenderingType }?,
    attribute columns { text }?

start = standard-document
}
